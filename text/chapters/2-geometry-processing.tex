\chapter{Background: Geometry Processing}

The field of \emph{geometry processing} is concerned with acquiring, manipulating and analyzing 3D surfaces.
Applications include simulations, modeling in industrial context, biomedical processing, and real-time 3D graphics (mostly, but not exclusively, for entertainment purposes).

A 3D surface can be acquired through a variety of different means.
In many areas, humans manually model 3D objects with a modeling software (like Blender\footnote{Blender website: \url{https://www.blender.org/}}), while in many other cases, 3D surfaces are algorithmically created from mathematical definitions or 3D scans (like MRI\footnote{Magnetic resonance imaging} data or laser scans).
It is then often necessary to manipulate the surface in order to improve certain characteristics of it.
For example, laser scan data is often fairly noisy, so various post-processing algorithms are needed to remove artifacts caused by that noise.
For real-time 3D graphics, it is often beneficial to reduce the complexity of an object in order to improve rendering times.
Also see \ref{fig:cat-algo} for two examples of modifying mesh algorithms.

To work with 3D surfaces, one first has to find a way to represent them.
Amongst the many very different kinds of representations (cf. \cite{botsch2010polygon}, chapter 1), the polygon mesh (or just \enquote{mesh} for short) is one of the most widely used one.
A polygon mesh is a collection of vertices (points, singular \emph{vertex}), edges (connecting two vertices) and faces (polygons bounded by edges).
It is important to note that polygon meshes can only exactly represent polyhedrons, so most of the time, they are just an approximation of the actual 3D surface.

\begin{figure}[b]
  \includesvg{cat-algo}
  \caption{A 3D model of a cat (center).
  The left and right meshes are the results of a \emph{simplification} and \emph{subdivision} operation, respectively.
  (Original model from \cite{catmodel})}
  \label{fig:cat-algo}
\end{figure}

There are two special forms of the polygon mesh of high practical relevance.
A \emph{triangle mesh} is a polygon mesh where each face is triangular and in a \emph{quad mesh}, all faces are quadrilaterals.
Restricting the faces like that often makes algorithms operating on that mesh a lot simpler (and thus potentially faster).
In particular, since triangles are the simplest polygon (a 2-simplex, in fact), many operations on triangle meshes are a lot faster than on a general polygon mesh.

\begin{figure}[t]
  \includesvg{non-manifolds}
  \caption{
    A non-manifold edge with more than two adjacent faces (left).
    A non-manifold vertex adjacent to one closed and one open fan (center).
    The red vertex on the right is technically also a non-manifold vertex (adjacent to two open fans).
    However, this configuration is allowed in most data structures (it can still be turned into a manifold mesh by inserting more faces).}
  \label{fig:non-manifold}
\end{figure}

The following list explains a few common terms related to meshes or geometry processing.

\begin{description}
  \item [\emph{Mesh element}] A vertex, edge or face.
  \item [\emph{Valence}] The valence of a vertex/face is the number of adjacent edges.
  \item [\emph{Isolated vertex}] A vertex with a valence of 0.
  \item [\emph{Boundary}] Meshes can have boundaries: edges with only one incident face.
  A mesh without boundaries is \textbf{\emph{closed}} (also called \textbf{\emph{watertight}}).
  A \emph{boundary edge} is an edge with exactly one adjacent face; a \emph{boundary vertex/face} is a vertex/face adjacent to at least one boundary edge.
  \item [\emph{Manifold}] A surface is \emph{2-manifold} if it locally resembles (is homeomorphic to) the Euclidean plane near each point.
  In simpler terms: the neighborhood (an infinitesimal sphere) around each point is continuously deformable into a 2D disc (or a half-disc for boundary points).
  The manifold-property trivially holds for all points inside of a face, but a mesh can contain non-manifold edges or vertices (cf. figure~\ref{fig:non-manifold}).
  A manifold edge has $\le 2$ incident faces.
  A manifold vertex can be removed without disconnecting its adjacent faces (often described as: it is only adjacent to one fan of triangles).
  A mesh is called manifold if does not contain any non-manifold edges nor non-manifold vertices.
  \item [\emph{Normal}] A surface normal of a point on a surface is the vector perpendicular to that surface at that point.
  \item [\emph{Orientable}] A mesh is orientable if it is possible to consistently assign a surface normal to every point on its surface.
  A famous example for a non-orientable mesh is the \emph{Möbius strip} (see figure~\ref{fig:moebius}).
\end{description}

\begin{figure}[t]
  \centering
  \includesvg[.7\textwidth]{moebius}
  \caption{The Möbius strip: a non-orientable mesh.
    On the right, directional lighting was used to shade the mesh.
    Since normals, which are crucial for lighting, cannot be chosen consistently, an artifact is visible where opposing normals met.}
  \label{fig:moebius}
\end{figure}


In many applications, meshes are expected to be manifold and orientable, as this makes working with them a lot easier.
In this thesis, all meshes are assumed to satisfy these properties as well.


\section{Mesh Data Structures}

In order to represent polygon meshes in a computer, some kind of data structure is needed.
We can distinguish two types of data we need to store: the connectivity information and additional \emph{mesh properties}.

A \emph{mesh property} is arbitrary data which is associated with elements of the mesh.
For example, 3D vertex positions -- a 3D vector associated with every vertex -- are such a property and are present in virtually every mesh.
Surface normals and texture coordinates are two properties that are stored in many meshes, too (they are also usually associated with each vertex).
For visualization, vertices, edges or faces can be colored, that is: associated a color with each element.
Lastly, many algorithms need to associated temporary values with mesh elements, like a boolean flag to store which element was already visited or some kind of cost.
In general, it is necessary to be able to associated arbitrary values with mesh elements.

As long as each mesh element can be uniquely identified, storing mesh properties is easy (e.\,g. in a hash map).
Instead, the difficulty lies in storing the connectivity of a mesh, because algorithms operating on meshes require various adjacency information.
For example, a simple way to smooth a mesh is to replace each vertex position with the centroid of all adjacent vertices.
That algorithm needs to be able to enumerate all neighbor vertices of a specific vertex.
% TODO: maybe show smoothing algorithm?

Generally, an algorithm might request all the neighbors of any mesh element. The following table shows the nine possible neighborhood queries.

\begin{center}
  \begin{minipage}{.52\textwidth}
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{| l || c | c | c |}
      \hline
      \hfill \textbf{$\lcurvearrowne$} & Vertex & Edge & Face\\\hline\hline
      Vertex
        & \adj[flat-blue-dark]{V}{V}
        & \adj[flat-green-dark]{V}{E}
        & \adj[flat-blue-dark]{V}{F} \\\hline
      Edge
        & \adj[flat-green-dark]{E}{V}
        & \adj[flat-red-dark]{E}{E}
        & \adj[flat-green-dark]{E}{F} \\\hline
      Face
        & \adj[flat-blue-dark]{F}{V}
        & \adj[flat-green-dark]{F}{E}
        & \adj[flat-blue-dark]{F}{F} \\\hline
    \end{tabular}
    \renewcommand{\arraystretch}{1}
  \end{minipage}
  \begin{minipage}{.42\textwidth}
    \footnotesize
    \begin{description}
      \item [\textcolor{flat-green-dark}{Green}] \emph{Real} neighbors. Are \enquote{complete}: all other information can be derived from these neighbors.
      \item [\textcolor{flat-blue-dark}{Blue}] Not \emph{real} neighbors, but very common queries in practice.
      \item [\textcolor{flat-red-dark}{Red}] Not \emph{real} neighbors; rarely used.
    \end{description}
  \end{minipage}
\end{center}

Algorithms often need slightly different kinds of information (like \enquote{are these two elements adjacent?}, \enquote{what is the valence of this vertex?}, or \enquote{is this face a boundary face?}), but all of these questions can be answered through the basic neighborhood queries shown above.

\vspace{1cm}

The challenge in creating a mesh data structure is about (a) providing all required connectivity information, (b) doing that as fast as possible, and (c) being as memory efficient as possible.

Just providing the information is not particularly difficult:
most data structures can provide all adjacency information in $\mathcal O(|V| + |F| + |E|)$.
However, in this thesis, \enquote{fast} implies a runtime of $\mathcal O(|r|)$ where $r$ is the result of the query (the neighbors). In the rest of this thesis, a statement like \enquote{cannot provide this information} might also mean \enquote{cannot provide this information in $\mathcal O(|r|)$}.
One could store all neighborhood information explicitly to meet those asymptotic runtime requirements (i.\,e. each face stores a list of all adjacent faces, a list of all adjacent edges and a list of all adjacent vertices; similarly for vertices and edges).
However, this approach has a tremendous memory overhead and it would be very slow to modify the mesh, as a lot of information has to be updated.


\subsection{Performance Characteristics of Modern Hardware}

In order to create fast data structures, some knowledge of modern computer hardware is required.
This sub-section gives a very coarse overview over some aspect of this topic.
A lot of information throughout this section is taken from \cite{hennessy2017computer}, particularly from chapter~2 and appendix~B.

For some decades now, the speed of processors improved more quickly than the memory speed.
On current hardware, accessing the main memory takes approximately between 50\,ns and 100\,ns.
As modern processors are clocked at approximately 3\,GHz, the memory access time equates to roughly 150 to 300 cycles.
To avoid wasting a lot of time waiting for memory, different techniques are used, the most notably being: \emph{CPU caches}.

The \emph{principle of locality} states that memory access patterns of programs tend to be fairly predictable.
Temporal locality means that recently accessed data is often accessed again shortly afterwards;
spatial locality means that consecutive memory accesses are usually accessing memory locations close to one another.
This behavior is exploited by CPU caches -- processor-internal memory that is smaller but a lot faster than main memory.
For each memory access, the processor checks whether the requested data is already present in one of the CPU caches.
If that is the case (a \emph{cache hit}), that value can be used and the main memory does not need to be accessed.
If the cache does not contain the requested data (a \emph{cache miss}), the value has to be loaded from main memory and is then stored in the cache.
Most modern processors have multiple layers of caches; see \ref{tbl:caches} for typical sizes and access times of caches from different layers.

\begin{table}[t]
  \centering
  \small
  \sffamily
  \begin{tabular}{llllll}
  & \textbf{CPU registers} & \textbf{L1 cache} & \textbf{L2 cache} & \textbf{L3 cache} & \textbf{Main memory} \\\hline
  \textbf{Size} & 1000\,bytes & 64\,KB & 256\,KB & 4--32\,MB & 4--64\,GB \\\hline
  \textbf{Access time} & One cycle ($\approx$ 300\,ps) & 1\,ns & 3--10\,ns & 10--20\,ns & 50--100\,ns \\\hline
  \end{tabular}
  \caption{Typical sizes and access times of different kinds of memories on a desktop computer (data taken from \cite{hennessy2017computer}).}
  \label{tbl:caches}
\end{table}

To use the spatial locality of programs, data is always loaded in \emph{cache lines}, blocks of memory typically 64 bytes long (on current x86 processors).
That way, accessing multiple values in one cache line only requires accessing main memory at most once.
Additionally, the \emph{prefetcher} is used to load new cache lines from main memory even before the program requests them (this is done by predicting what memory is likely to be accessed next).

As a consequence of CPU caches, the execution time of a program can be increased (dramatically in many cases) by making it more \enquote{cache friendly}: making sure that memory access patterns are predictable and follow the principle of locality.
For example, iterating over an array (which stores its elements contiguously in memory) is one of the most cache friendly things to do, while iterating over a linked list is the exact opposite.
In the latter case, since each list node is usually allocated on its own, each element access is likely a cache miss.

Traversing a polygon mesh is usually not particularly cache friendly.
As polygon meshes represent 2D surfaces, but the memory address space has only one dimension, most adjacent mesh elements cannot be stored close to each other in memory.
While perfect cache friendliness is impossible to achieve for polygon meshes, it is still important to make sure a data structure causes as few cache misses as possible.
This has a few different consequences.

In many programming languages, it seems natural to refer to mesh elements via pointers or references.
This is problematic, however, since this approach requires a stable allocation for each element: the element cannot be moved in memory after the initial allocation.
Unfortunately, all ways of achieving stable pointers (e.\,g. by using a linked lists) are inherently cache unfriendly.
A faster alternative is to store all elements in a growing array and refer to them via an index into that array (pointers cannot be used since they are invalidated when the growing array has to reallocate).
This can be less convenient but has the additional bonus that the indices can often be stored with only 32 bits, reducing the memory consumption of the data structure on 64-bit platforms.

Furthermore, storing dynamic lists (a sequence of elements which length is not known at compile time) should be avoided.
If at all, this sequence should be stored in a growing array and not a linked list.
This would require storing the length of the sequence, causing memory overhead.
But more importantly, the list data cannot be stored inline, requiring separate allocations and causing cache misses when accessing the data.

\newpage
\subsection{Existing Mesh Data Structures}

Over the years, many data structures for meshes have been developed -- differing in capabilities, speed and memory efficiency.
This chapter will give an overview over the most commonly used ones, but will exclude data structures like the \emph{triangle soup} which does not store any adjacency information at all.

Generally, two types of data structures can be distinguished: \emph{face-based} and \emph{edge-based} data structures.
The former store the main adjacency information per face, the latter per edge.
As discussed in the last section, storing lists with dynamic length is usually very inefficient and should be avoided.
As can be seen in table~\ref{tab:max-neighbors}, the number of possible neighbors of vertices are unbounded, which is why there are no relevant vertex-based data structures.
The table also shows that face-based data structures are only efficient if the valence of faces is fixed (e.g. a triangle or quad mesh), as otherwise dynamic lists are required.

\begin{table}[t]
  \centering
  \renewcommand{\arraystretch}{1.1}
  \begin{tabular}{|l|c|c|c|}
    \hline
    & \adj{V}{\{V|E|F\}} & \adj{E}{\{V|F\}} & \adj{F}{\{V|E|F\}} \\[.8mm]\hline
    Triangle Mesh & $\infty$ & 2 & 3 \\\hline
    Quad Mesh     & $\infty$ & 2 & 4 \\\hline
    Polygon Mesh  & $\infty$ & 2 & $\infty$ \\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1}
  \caption{Maximum number of neighbors of mesh elements. }
  \label{tab:max-neighbors}
\end{table}

Note that mesh properties, including vertex positions, are completely ignored in this subsection.
Whether these properties should be stored externally or next to the adjacency information is discussed later.

\newlength{\braceWidth}%
\newlength{\demColWidth}%

\subsubsection*{Shared Vertex Mesh}

\begin{figure}[h]
  \centering
  \begin{minipage}{.35\textwidth}
    \includesvg{shared-vertex}
  \end{minipage}
  \hspace{2cm}
  \begin{minipage}{.3\textwidth}
    \small
    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{face}} \\\hline
      \code{vertex0: Vertex}\\\hline
      \code{vertex1: Vertex}\\\hline
      \code{vertex2: Vertex}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{vertex}} \\\hline
      \emph{nothing}\\\hline
    \end{tabular}

  \end{minipage}

  \vspace{7mm}

  \setlength{\demColWidth}{7mm}
  \setlength{\dashlinedash}{.4mm}
  \setlength{\dashlinegap}{.4mm}
  \setlength{\tabcolsep}{0.2mm}

  \renewcommand{\arraystretch}{1.2}
  Faces: \hspace{5mm}
  \makebox[0pt][l]{%
    \raisebox{-1.7ex}{%
      \setlength{\braceWidth}{3\demColWidth}%
      \addtolength{\braceWidth}{2\tabcolsep}%
      \Large %
      \hspace{.5mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_0}$%
      \hspace{1.7mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_1}$%
    }%
  }%
  \begin{tabular}{|%
    C{\demColWidth}:C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}|%
  }\hline
    $v^0_0$ & $v^1_0$ & $v^2_0$ &
    $v^0_1$ & $v^1_1$ & $v^2_1$ &
    \dots \\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}

  \vspace{2mm}
  \caption{Structure of a shared vertex mesh.}
  \label{fig:sv-structure}
\end{figure}

This face-based data structure, also called \emph{indexed face set}, is the simplest and arguably the most used one.
It uses very little memory, but is quite restricted in its standard version:
it can only store triangular faces and cannot provide any adjacency information apart from \adj{F}{V}.
These limitations do not pose a problem for most real-time 3D applications, however, as \adj{F}{V} is sufficient for rendering and most graphic APIs (like Vulkan or OpenGL) only support triangle meshes anyway.
For that reason, this data structure is used almost everywhere in real-time rendering.

A shared vertex mesh only stores the adjacent vertices for each face.
Since this data structure is almost exclusively used for triangle meshes, the list of adjacent vertices can be stored inline, making it very cache-friendly and memory efficient.
Edges are not stored at all and cannot be referred to. See figure~\ref{fig:sv-structure}.


\subsubsection*{Half Edge Mesh}

Often abbreviated \emph{HEM}, this data structure splits each edges into two \emph{half edges} and stores most connectivity information in those. Thus, it is a (half-)edge-based data structure.
A HEM can provide all connectivity information. (Cf. \cite{mantyla1988introduction})

Each face/vertex only stores a reference to an arbitrary adjacent/outgoing half edge, respectively.
Each half edges stores the vertex it is pointing at (\emph{target}), the face it is adjacent to, its \emph{twin} and the next half edge counter-clockwise around the face (or hole) it is adjacent to.
Optionally, the previous half edge (around the adjacent face) is also stored, which increases memory consumption, but makes some operations faster.
The \emph{twin} reference is typically not stored explicitly, but encoded implicitly by making sure twin half edges are always stored next to each other in memory.
See figure~\ref{fig:hem-structure}.

\begin{figure}[h]
  \centering
  \begin{minipage}{.47\textwidth}
    \includesvg{hem}
  \end{minipage}
  \begin{minipage}{.4\textwidth}
    \small
    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{face}} \\\hline
      \code{edge: HalfEdge}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{vertex}} \\\hline
      \code{outgoing: HalfEdge?}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{half edge}} \\\hline
      \code{target: Vertex}\\\hline
      \code{face: Face?}\\\hline
      \code{next: HalfEdge}\\\hline
      \code{prev: HalfEdge} (optional)\\\hline
      \code{twin: HalfEdge} (stored implicitly)\\\hline
    \end{tabular}
  \end{minipage}

  \vspace{5mm}

  \setlength{\demColWidth}{7mm}

  \setlength{\dashlinedash}{.4mm}
  \setlength{\dashlinegap}{.4mm}
  \setlength{\tabcolsep}{0.2mm}

  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{ll}
  Vertices: &
  \begin{tabular}{|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|}\hline
    $e^\text{out}_0$ & $e^\text{out}_1$ & $e^\text{out}_2$ & $e^\text{out}_3$ & \dots \\\hline
  \end{tabular} \\[3mm]
  Faces: &
  \begin{tabular}{|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|}\hline
    $e_0$ & $e_1$ & $e_2$ & $e_3$ & \dots \\\hline
  \end{tabular} \\[3mm]
  Half edges: \hspace{5mm} &
  \makebox[0pt][l]{%
    \raisebox{-1.7ex}{%
      \setlength{\braceWidth}{3\demColWidth}%
      \addtolength{\braceWidth}{3\tabcolsep}%
      \Large %
      \hspace{.5mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_0}$%
      \hspace{1.1mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_1}$%
      \hspace{1.1mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_2}$%
    }%
  }%
  \begin{tabular}{|%
    C{\demColWidth}:C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}|%
  }\hline
    $v^t_0$ & $f_0$ & $e^n_1$ &
    $v^t_1$ & $f_1$ & $e^n_1$ &
    $v^t_2$ & $f_2$ & $e^n_2$ &
    \dots \\\hline
  \end{tabular}\\
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}

  \vspace{2mm}
  \caption{
    Structure of a half edge mesh.
    A \codebox{?} in the table denotes a value that can be absent (\emph{null}/\codebox{None}).
  }
  \label{fig:hem-structure}
\end{figure}




\subsubsection*{Directed Edge Mesh}

Todo.

\begin{figure}[h]
  \centering
  \begin{minipage}{.47\textwidth}
    \includesvg{dem}
  \end{minipage}
  \begin{minipage}{.4\textwidth}
    \small
    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{face}} \\\hline
      \emph{nothing}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{vertex}} \\\hline
      \code{outgoing: HalfEdge?}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{half edge}} \\\hline
      \code{target: Vertex}\\\hline
      \code{twin: HalfEdge}\\\hline
      \code{next: HalfEdge} (optional/implicit)\\\hline
      \code{prev: HalfEdge} (optional/implicit)\\\hline
    \end{tabular}
  \end{minipage}

  \vspace{5mm}

  \setlength{\demColWidth}{7mm}

  \setlength{\dashlinedash}{.4mm}
  \setlength{\dashlinegap}{.4mm}
  \setlength{\tabcolsep}{0.2mm}

  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{ll}
  Vertices: &
  \begin{tabular}{|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|C{\demColWidth}|}\hline
    $e^\text{out}_0$ & $e^\text{out}_1$ & $e^\text{out}_2$ & $e^\text{out}_3$ & \dots \\\hline
  \end{tabular} \\[4mm]
  Half edges: \hspace{5mm} &
  \makebox[0pt][l]{%
    \raisebox{-1.7ex}{%
      \setlength{\braceWidth}{6\demColWidth}%
      \addtolength{\braceWidth}{12\tabcolsep}%
      \Large %
      \hspace{.5mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_0}$%
      \hspace{1.7mm}%
      $\underbrace{\hspace{\braceWidth}}_{F_1}$%
    }%
  }%
  \makebox[0pt][l]{%
    \raisebox{2.5ex}{%
      \setlength{\braceWidth}{2\demColWidth}%
      \addtolength{\braceWidth}{2\tabcolsep}%
      \Large %
      \hspace{.4mm}%
      $\overbrace{\hspace{\braceWidth}}^{\text{HE}_0}$%
      \hspace{.75mm}%
      $\overbrace{\hspace{\braceWidth}}^{\text{HE}_1}$%
      \hspace{.75mm}%
      $\overbrace{\hspace{\braceWidth}}^{\text{HE}_2}$%
      \hspace{1.4mm}%
      $\overbrace{\hspace{\braceWidth}}^{\text{HE}_3}$%
      \hspace{.75mm}%
      $\overbrace{\hspace{\braceWidth}}^{\text{HE}_4}$%
      \hspace{.75mm}%
      $\overbrace{\hspace{\braceWidth}}^{\text{HE}_5}$%
    }%
  }%
  \begin{tabular}{|%
    C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}||%
    C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}|%
    C{\demColWidth}:C{\demColWidth}||%
    C{\demColWidth}|%
  }\hline
    $v^\text{ta}_0$ & $e^\text{tw}_0$ &
    $v^\text{ta}_1$ & $e^\text{tw}_1$ &
    $v^\text{ta}_2$ & $e^\text{tw}_2$ &
    $v^\text{ta}_3$ & $e^\text{tw}_3$ &
    $v^\text{ta}_4$ & $e^\text{tw}_4$ &
    $v^\text{ta}_5$ & $e^\text{tw}_5$ &
    \dots \\\hline
  \end{tabular}\\
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}

  \vspace{2mm}

  \caption{
    Structure of a directed edge mesh.
    A \codebox{?} in the table denotes a value that can be absent (\emph{null}/\codebox{None}).
  }
  \label{fig:dem-structure}
\end{figure}

\subsubsection*{Other data structures}

Besides the shared vertex mesh, there are other, more capable face-based data structures.
They usually store one arbitrary adjacent face for each vertex and all adjacent vertices plus additional data per face.
In the simplest form, this additional data consists of all adjacent faces (per face), but it can be more elaborate than this.
Interestingly, these data structures are often not discussed in-depth in literature, but instead quickly dismissed as not sufficient, because they do not explicitly store edges and are restricted to triangle/quad meshes.
Not being able to refer to edges can indeed be a problem in many situations, but by far not every algorithm deals with edges explicitly.

Two other well known, edge-based data structures are the \emph{quad-edge mesh} \cite{guibas1985primitives} and the \emph{winged-edge mesh} \cite{baumgart1972winged}.

% TODO: add table comparing mesh data structures!


\section{Existing Geometry Processing Libraries}

There are a variety of software libraries and frameworks for geometry processing, often with different features and capabilities.
Most of them are open-source software.
This section gives an incomplete overview over those libraries and frameworks.

\begin{description}
  \item [OpenMesh] Developed at the RTWH Aachen, OpenMesh \cite{botsch2002openmesh,openmeshhomepage} is one of the most used polygon mesh library.
  It is the basis for OpenFlipper \cite{mobius2010openflipper, openflipperhomepage}, a geometry processing and rendering framework mainly developed at the same university.
  (OpenFlipper is disregarded in this thesis, as it doesn't provide its own data structures.)

  The library is cross-platform, written in \cpp (though it also offers Python bindings) and mainly features a customizable implementation of a half-edge mesh.
  Those compile-time customizations allow the user to, for example, choose whether or not \code{prev} references are stored and whether the mesh should be restricted to triangular faces.
  On top of the main data structures, multiple algorithms and functionality for reading and writing files of different formats are implemented.

  \item [CGAL] The \textbf{C}omputational \textbf{G}eometry \textbf{A}lgorithms \textbf{L}ibrary \cite{cgalhomepage} offers a wide variety of different algorithms and data structures for everything related to computational geometry.
  This includes features beyond 3D meshes, like point set processing, nearest-neighbor search, surface reconstruction and many more.
  Its main mesh data structure is also the half-edge mesh (see \cite{cgal:k-hds-19a, cgal:bsmf-sm-19a}), but the library also uses different or more specialized data structures for some tasks.

  \item [PMP] The \textbf{P}olygon \textbf{M}esh \textbf{P}rocessing library \cite{pmp-library}, written in \cpp, offers a half-edge mesh data structure, several mesh algorithms and functionality for visualizing meshes.
  Version 1.0 was released on 2019/02/18.
  The implementation of the mesh data structure is based on the \code{Surface_mesh} implementation discussed in \cite{sieger2011design}.

  \item [VCGlib] A \cpp library for manipulating, processing and displaying 3D meshes \cite{vcglibhomepage}.
  Most notably, it is used in the software MeshLab \cite{meshlabhomepage}.
  Its basic data structure is a shared vertex mesh which can be extended with additional adjacency information and supports many non-manifold features.

  \item [Plexus] \enquote{Plexus is a Rust library for processing 2D and 3D meshes} \cite{plexus}.
  As of May 2019, the library is still in its initial development phase offering no API stability guarantees yet.
  It also uses a half edge mesh to store adjacency information.
\end{description}

\chapter{Background: Geometry Processing}

The field of \emph{geometry processing} is concerned with acquiring, manipulating and analyzing 3D surfaces.
Applications include simulations, modeling in industrial context, biomedical processing, and real-time 3D graphics (mostly, but not exclusively, for entertainment purposes).

A 3D surface can be acquired through a variety of different means.
In many areas, humans manually model 3D objects with a modeling software (like Blender\footnote{Blender website: \url{https://www.blender.org/}}), while in many other cases, 3D surfaces are algorithmically created from mathematical definitions or 3D scans (like MRI\footnote{Magnetic resonance imaging} data or laser scans).
It is then often necessary to manipulate the surface in order to improve certain characteristics of it.
For example, laser scan data is often fairly noisy, so various post-processing algorithms are needed to remove artifacts caused by that noise.
For real-time 3D graphics, it is often beneficial to reduce the complexity of an object in order to improve rendering times.
Also see \ref{fig:cat-algo} for two examples of modifying mesh algorithms.

To work with 3D surfaces, one first has to find a way to represent them.
Amongst the many very different kinds of representations (cf. \cite{botsch2010polygon}, chapter 1), the polygon mesh (or just \enquote{mesh} for short) is one of the most widely used one.
A polygon mesh is a collection of vertices (points, singular \emph{vertex}), edges (connecting two vertices) and faces (polygons bounded by edges).
It is important to note that polygon meshes can only exactly represent polyhedrons, so most of the time, they are just an approximation of the actual 3D surface.

\begin{figure}[b]
  \includesvg{cat-algo}
  \caption{A 3D model of a cat (center).
  The left and right meshes are the results of a \emph{simplification} and \emph{subdivision} operation, respectively.
  (Original model from \cite{catmodel})}
  \label{fig:cat-algo}
\end{figure}

There are two special forms of the polygon mesh of high practical relevance.
A \emph{triangle mesh} is a polygon mesh where each face is triangular and a \emph{quad mesh}, all faces are quadrilaterals.
Restricting the faces like that often makes algorithms operating on that mesh a lot simpler (and thus potentially faster).
In particular, since triangles are the simplest polygon (a 2-simplex, in fact), many operations on triangle meshes are a lot faster than on a general polygon mesh.

\begin{figure}[t]
  \includesvg{non-manifolds}
  \caption{
    A non-manifold edge with more than two adjacent faces (left).
    A non-manifold vertex adjacent to one closed and one open fan (center).
    The red vertex on the right is technically also a non-manifold vertex (adjacent to two open fans).
    However, this configuration is allowed in most data structures as it can still lead to a manifold mesh (by inserting more faces).}
  \label{fig:non-manifold}
\end{figure}

The following list explains a few common terms related to meshes or geometry processing.

\begin{description}
  \item [\emph{Mesh element}] A vertex, edge or face.
  \item [\emph{Valence}] The valence of a vertex/face is the number of adjacent edges.
  \item [\emph{Isolated vertex}] A vertex with a valence of 0.
  \item [\emph{Boundary}] Meshes can have boundaries: edges with only one incident face.
  A mesh without boundaries is \textbf{\emph{closed}} (also called \textbf{\emph{watertight}}).
  A \emph{boundary edge} is an edge with exactly one adjacent face; a \emph{boundary vertex/face} is a vertex/face adjacent to at least one boundary edge.
  \item [\emph{Manifold}] A surface is \emph{2-manifold} if it locally resembles (is homeomorphic to) a Euclidean plane near each point.
  In simpler terms: the neighborhood (an infinitesimal sphere) around each point is continuously deformable into a 2D disc (or a half-disc for boundary points).
  The manifold-property trivially holds for all points inside of a face, but there can be non-manifold edges or vertices (cf. figure~\ref{fig:non-manifold}).
  A manifold edge has $\le 2$ incident faces.
  A manifold vertex can be removed without disconnecting its adjacent faces (often described as: it is only adjacent to one fan of triangles).
  A mesh is called manifold if does not contain any non-manifold edges nor non-manifold vertices.
  \item [\emph{Normal}] A normal of a point on a surface is the vector perpendicular to that surface.
  \item [\emph{Orientable}] A mesh is orientable if it is possible to consistently assign a surface normal to every point on its surface.
  A famous example for a non-orientable mesh is the \emph{Möbius strip} (see figure~\ref{fig:moebius}).
\end{description}

\begin{figure}[t]
  \centering
  \includesvg[.35\textwidth]{moebius}
  \caption{The Möbius strip: a non-orientable mesh.}
  \label{fig:moebius}
\end{figure}


In many applications, meshes are expected to be manifold and orientable, as this makes working with them a lot easier.
In this thesis, all meshes are assumed to satisfy these properties as well.


\section{Mesh Data Structures}
% - requirements of data structures (adj info)
% - what makes DS slow/fast? Caches, ...
% - list and short explanation of different data structures

In order to represent polygon meshes in a computer, some kind of data structure is needed.
We can distinguish two types of data we need to store: the connectivity information and additional \emph{mesh properties}.

A \emph{mesh property} is arbitrary data which is associated with elements of the mesh.
For example, 3D vertex positions -- a 3D vector associated with every vertex -- are such a property and are present in virtually every mesh.
Surface normals and texture coordinates are two properties that are stored in many meshes, too (they are also usually associated with each vertex).
For visualization, vertices, edges or faces can be colored, that is: associated a color with each element.
Lastly, many algorithms need to associated temporary values with mesh elements, like a boolean flag to store which element was already visited or some kind of cost.
In general, it is necessary to be able to associated arbitrary values with mesh elements.

As long as each mesh element can be uniquely identified, storing mesh properties is easy (e.\,g. in a hash map).
Instead, the difficulty lies in storing the connectivity of a mesh, because algorithms operating on meshes require various adjacency information.
For example, a simple way to smooth a mesh is to replace each vertex position with the centroid of all adjacent vertices.
That algorithm needs to be able to enumerate all neighbor vertices of a specific vertex.
% TODO: maybe show smoothing algorithm?

Generally, an algorithm might request all the neighbors of any mesh element. The following table shows the nine possible neighborhood queries.

\begin{center}
  \begin{minipage}{.52\textwidth}
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{| l || c | c | c |}
      \hline
      \hfill \textbf{$\lcurvearrowne$} & Vertex & Edge & Face\\\hline\hline
      Vertex
        & \adj[flat-blue-dark]{V}{V}
        & \adj[flat-green-dark]{V}{E}
        & \adj[flat-blue-dark]{V}{F} \\\hline
      Edge
        & \adj[flat-green-dark]{E}{V}
        & \adj[flat-red-dark]{E}{E}
        & \adj[flat-green-dark]{E}{F} \\\hline
      Face
        & \adj[flat-blue-dark]{F}{V}
        & \adj[flat-green-dark]{F}{E}
        & \adj[flat-blue-dark]{F}{F} \\\hline
    \end{tabular}
    \renewcommand{\arraystretch}{1}
  \end{minipage}
  \begin{minipage}{.42\textwidth}
    \footnotesize
    \begin{description}
      \item [\textcolor{flat-green-dark}{Green}] \emph{Real} neighbors; already provides all neighborhood information.
      \item [\textcolor{flat-blue-dark}{Blue}] Not \emph{real} neighbors; but very common query.
      \item [\textcolor{flat-red-dark}{Red}] Not \emph{real} neighbors; rarely used.
    \end{description}
  \end{minipage}
\end{center}

Algorithms often need slightly different kind of information (like \enquote{are these two elements adjacent?}, \enquote{what is the valence of this vertex?}, or \enquote{is this face a boundary face?}), but all of these questions can be answered through the basic neighborhood queries shown above.

\vspace{1cm}

The challenge in creating a mesh data structure is about (a) providing all required connectivity information, (b) doing that as fast as possible, and (c) being as memory efficient as possible.

Just providing the information is not particularly difficult:
most data structures can provide all adjacency information in $\mathcal O(|V| + |F| + |E|)$.
However, in this thesis, \enquote{fast} implies a runtime of $\mathcal O(|r|)$ where $r$ is the result of the query (the neighbors). In the rest of this thesis, a statement like \enquote{cannot provide this information} might also mean \enquote{cannot provide this information in $\mathcal O(|r|)$}.
One could store all neighborhood information explicitly to meet those asymptotic runtime requirements (i.\,e. each face stores a list of all adjacent faces, a list of all adjacent edges and a list of all adjacent vertices; similarly for vertices and edges).
However, this approach has a tremendous memory overhead and it would be very slow to modify the mesh, as a lot of information has to be updated.


\subsection{Performance Characteristics of Modern Hardware}

% In the last few decades, one factor became increasingly important for the speed of programs dealing with a lot of data: CPU caches. Accessing the main memory (RAM) is relatively slow, taking around 100 CPU-cycles on modern systems.

% The latency of main memory (RAM) is fairly high compared to the CPU speed,

% While the clock speed of CPUs grew continuously in that time, the latency of the main memory (RAM) did not improve nearly as fast. As such, memory accesses quickly became the bottleneck in many applications. In order to tackle this problems, CPU manufacturers introduced more and more caches directly into the CPU.

% TODO: how to refer to elements? -> index


\subsection{Existing Mesh Data Structures}

Over the years, many data structures for meshes have been developed -- differing in capabilities, speed and memory efficiency.
This chapter will give an overview over the most commonly used ones, but will exclude data structures like the \emph{triangle soup} which does not store any adjacency information at all.

Generally, two types of data structures can be distinguished: \emph{face-based} and \emph{edge-based} data structures.
The former store the main adjacency information per face, the latter per edge.
As discussed in the last section, storing lists with dynamic length is usually very inefficient and should be avoided.
As can be seen in table~\ref{tab:max-neighbors}, the number of possible neighbors of vertices are unbounded, which is why there are no relevant vertex-based data structures.
The table also shows that face-based data structures are only efficient if the valence of faces is fixed (e.g. a triangle or quad mesh), as otherwise dynamic lists are required.

\begin{table}[t]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|l|c|c|c|}
    \hline
    & \adj{V}{\{V|E|F\}} & \adj{E}{\{V|F\}} & \adj{F}{\{V|E|F\}} \\[.8mm]\hline
    Triangle Mesh & $\infty$ & 2 & 3 \\\hline
    Quad Mesh     & $\infty$ & 2 & 4 \\\hline
    Polygon Mesh  & $\infty$ & 2 & $\infty$ \\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1}
  \caption{Maximum number of neighbors of mesh elements. }
  \label{tab:max-neighbors}
\end{table}

\subsubsection*{Shared Vertex Mesh}
This face-based data structure, also called \emph{indexed face set}, is the simplest and arguably the most used one.
It uses very little memory, but is quite restricted in its standard version:
it can only store triangular faces and cannot provide any adjacency information apart from \adj{F}{V}.
These limitations do not pose a problem for most real-time 3D applications, however, as \adj{F}{V} is sufficient for rendering and most graphic APIs (like Vulkan or OpenGL) only support triangle meshes anyway.
For that reason, this data structure is used almost everywhere in real-time rendering.

A shared vertex mesh only stores all adjacent vertices for all faces.
Since this data structure is almost exclusively used for triangle meshes, the list of adjacent vertices can be stored inline, making it very cache-friendly and memory efficient.
Edges are not stored at all and cannot be referred to. See figure~\ref{fig:sv-structure}.


\begin{figure}[b]
  \centering
  \begin{minipage}{.35\textwidth}
    \includesvg{shared-vertex}
  \end{minipage}
  \hspace{2cm}
  \begin{minipage}{.3\textwidth}
    \small
    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{face}} \\\hline
      \code{vertex0: Vertex}\\\hline
      \code{vertex1: Vertex}\\\hline
      \code{vertex2: Vertex}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{vertex}} \\\hline
      \emph{nothing}\\\hline
    \end{tabular}

  \end{minipage}
  \vspace{2mm}
  \caption{Structure of a shared vertex mesh.}
  \label{fig:sv-structure}
\end{figure}


\subsubsection*{Half Edge Mesh}

Often abbreviated \emph{HEM}, this data structure splits each edges into two \emph{half edges} and stores most connectivity information in those. Thus, it is a (half-)edge-based data structure.
A HEM can provide all connectivity information. (Cf. \cite{mantyla1988introduction})

Each face/vertex only stores a reference to an arbitrary adjacent/outgoing half edge, respectively.
Each half edges stores the vertex it is pointing at (\emph{target}), the face it is adjacent to, its \emph{twin} and the next half edge counter-clockwise around the face (or hole) it is adjacent to.
Optionally, the previous half edge (around the adjacent face) is also stored, which increases memory consumption, but makes some operations faster.
The \emph{twin} reference is typically not stored explicitly, but encoded implicitly by making sure twin half edges are always stored next to each other in memory.
See figure~\ref{fig:hem-structure}.

\begin{figure}[t]
  \centering
  \begin{minipage}{.47\textwidth}
    \includesvg{hem}
  \end{minipage}
  \begin{minipage}{.4\textwidth}
    \small
    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{face}} \\\hline
      \code{edge: HalfEdge}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{vertex}} \\\hline
      \code{outgoing: HalfEdge?}\\\hline
    \end{tabular}

    \vspace{3mm}

    \begin{tabular}{|p{\textwidth}|}\hline
      \textbf{Data per \emph{half edge}} \\\hline
      \code{target: Vertex}\\\hline
      \code{face: Face?}\\\hline
      \code{next: HalfEdge}\\\hline
      \code{prev: HalfEdge} (optional)\\\hline
      \code{twin: HalfEdge} (stored implicitly)\\\hline
    \end{tabular}
  \end{minipage}
  \vspace{2mm}
  \caption{Structure of a half edge mesh. A \codebox{?} in the table denotes a value that can be \emph{null}/\codebox{None}.}
  \label{fig:hem-structure}
\end{figure}


\subsubsection*{Directed Edge Mesh}

Todo.

\subsubsection*{Other data structures}

Besides the shared vertex mesh, there are other, more capable face-based data structures.
They usually store one arbitrary adjacent face for each vertex and all adjacent vertices plus additional data per face.
In the simplest form, this additional data consists of all adjacent faces (per face), but it can be more elaborate than this.
Interestingly, these data structures are often not discussed in-depth in literature, but instead quickly dismissed as not sufficient, because they do not explicitly store edges and are restricted to triangle/quad meshes.
Not being able to refer to edges can indeed be a problem in many situations, but by far not every algorithm deals with edges explicitly.

Two other well known, edge-based data structures are the \emph{quad-edge mesh} \cite{guibas1985primitives} and the \emph{winged-edge mesh} \cite{baumgart1972winged}.




\section{Existing Geometry Processing Libraries}

\chapter{Background: Rust}

\emph{Rust}\footnote{Website: \url{https://www.rust-lang.org/}} is a general-purpose, open-source systems programming language\footnote{A \enquote{system programming language} is a language that is well suited to build system software, like operating systems, browser engines and device drivers. These language give the programmer low-level access to the computer hardware.} focused on reliability, performance and memory safety.
It is openely developed by the Rust community, with core developers being funded by Mozilla\footnote{Mozilla is mainly known for the browser \emph{Firefox} and its involvement with researching and standardising web-technologies. Website: \url{https://www.mozilla.org}}.
Its first stable version was release in May, 2015.
Since then, a new, fully backwards-compatible version is released every six weeks.
Rust was voted \enquote{most loved programming language} four times in a row from 2015 -- 2019 in the StackOverflow\footnote{A question \& answer website for programmers with over 10 million registered users as of January, 2019 \cite{so-user-count}. Website: \url{https://stackoverflow.com/}} Developer Survey -- one of the largest annual programmer-focussed surveys \cite{so-survey}.

\begin{figure}[h]
  \vspace{5mm}
  \centering
  \includesvg[.68\textwidth]{rust-logo-ferris}
  \caption{The Rust logo (left, \protect\hyperlink{cc-by}{CC-BY 4.0}) and the unofficial mascot of Rust (right, \protect\hyperlink{cc0}{CC0}).}
  \vspace{5mm}
\end{figure}

Rust is categorized as a multi-paradigm programming language; it is mainly imperative and structured, but has many features to allow for different programming paradigms, like functional or declarative programming.
Its design is influenced by many other programming languages, most importantly \cpp, Haskell and OCaml \cite{rust-influences}.
A strong, static type system is at the core of the language, enabling many of Rust's main features (this is explained in more detail below).
Rust is also a cross-platform language, running on different operating systems (including Linux, Windows, macOS, Android and iOS) and different CPU architectures (including x86, ARM, WASM and MIPS) \cite{rust-platforms}.

Rust does not have a \emph{garbage collector} (GC) and is compiled to native machine code in a native executable format.
The code generation is done by LLVM \cite{llvmwebsite, lattner2004llvm}, a collection of libraries and tools related to building compilers.
LLVM is also used by the \cpp compiler \code{clang++}, among others.
Like in \cpp, resource management (including memory management) is handled by the \emph{RAII} idiom \cite{raiihackcraft, stroustrup2001exception}.
This means that resources are released in so called \emph{destructor} functions (called \code{drop} in Rust) which are called automatically if an instance is destroyed (e.\,g. by going out of scope).

An important principle of Rust is the notion of \emph{zero cost abstractions} -- a term coined by \cpp.
As described by Stroustrup: \enquote{\cpp implementations obey the zero-overhead principle: What you don’t use, you don’t pay for [...]. And further: What you do use, you couldn’t hand code any better} \cite{stroustrup2012foundations}.
Due to the focus on making abstractions \emph{zero cost} and LLVM's high-quality code generation, Rust programs achieve execution speeds equivalent to \cpp or C programs (sometimes a bit slower, sometimes a bit faster).

After installing Rust, the command line tools \code{rustc}, \code{cargo} and \code{rustup} (amongst others) are available.
\emph{Cargo} is Rust's dependency manager and build tool which can use the official package repository \url{https://crates.io}.
The ability to easily and reliably include libraries into a project sets Rust apart from most other system programming languages.
\emph{Rustup} is a compiler version manager, which is also used to install additional tools and to setup cross-compilation.

Since Rust's initial release, it has been adopted by more and more programmers.
It is already used in production by hundreds of companies, most notably: Dropbox, NPM, Mozilla, Yelp \cite{rust-production}.

This chapter gives a very quick overview over the parts of Rust most important to this thesis.
To learn more about Rust, a large number of resources are available, including \emph{The Rust Programming Language} \cite{klabnik2018rust} which is available for free at \url{https://doc.rust-lang.org/book/}.
Also worth mentioning is the \enquote{Rust Playground}, an online compiler for quick testing, available at \url{https://play.rust-lang.org/}.
In this chapter, many code snippets contain a link to the playground containing that code (obviously only usable in the digital version of this thesis).


\section{Basic Syntax and Semantics}

The following code snippet (showing a not particularly useful program) demonstrates Rust's basic syntax and many other basic features.
The code is explained in more detail below.

\playground{https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=06d3e3f17909c9c73cb68f0fbb7956ea}

\begin{rustcode}
use std::{
    thread,
    time::Duration,
};

fn main() {
    const START: u64 = 871;

    let seq = collatz(START);
    println!("Collatz sequence of {} has a length of {}", START, seq.len());

    thread::sleep(Duration::from_millis(1500));
    println!("Bye!");
}

/// Generates and returns the Collatz sequence starting from `start`,
/// excluding `start` itself.
fn collatz(start: u64) -> Vec<u64> {
    let mut number = start;
    let mut steps = Vec::new();
    while number != 1 {
        number = if number % 2 == 0 { number / 2 } else { number * 3 + 1 };
        steps.push(number);
    }

    steps
}
\end{rustcode}

Explanations and remarks about the code above:
\vspace{-3mm}
\begin{itemize}
  \item A library in Rust is a single compilation unit, called a \emph{crate}.
  Each crate defines symbols in a module tree.
  Modules are similar to namespaces in \cpp, but the module trees in Rust are often deeper than nested namespaces in \cpp.
  \code{::} is used as separator in paths to symbols (e.\,g. \code{std::time::Duration}).
  With \code{use} (line~1), symbol names can be imported into scope.
  A few very important names (listed in \code{std::prelude}) are always imported.
  \item The keyword \code{fn} defines a function.
  Parameters are listed in the parenthesis after the function name (parameter name and type are flipped compared to \cpp), the return type is specified after \code{->}.
  \item The \code{main} function (line~6) is the entry point of Rust programs.
  \item Variables (more specifically: \emph{variable bindings}) are created with \code{let} (line~9).
  \item Rust is completely statically typed, but very elaborate type inference allows to omit type annotations in many places.
  They are usually only necessary in function signatures, types and \code{const} definitions.
  \item \code{println} (line~10) is a macro which is used for printing to stdout.
  Macros are invoked with the \code{!} after the name and operate on the source code and not on values, which makes them more powerful than normal functions in some situations.
  \item There are no \emph{constructors} in Rust.
  Instead, static methods (called \emph{associated functions} in Rust) returning an instance of the type are used.
  Examples: \code{Duration::from_millis} (line~12) and \code{Vec::new}  (line~20); \code{new} is not a keyword, but simply the function's name.
  \item \code{Vec<T>} is equivalent to \code{std::vector<T>} in \cpp: a growable array with elements of type \code{T}.
  \item Variable bindings are immutable by default.
  The keyword \code{mut} (line~19 and 20) is necessary to make them mutable.
  This is exactly the opposite of the default behavior in languages like \cpp and Java.
  This is useful, because in normal Rust code (unlike in this example), immutable bindings significantly outnumber mutable ones.
  \item In control structures like \code{if} and \code{while}, the boolean expression does not need to be wrapped inside parenthesis \code{()}, but the body always has to be wrapped in braces \code|{}|.
  This is, again, exactly the opposite of the rules in \cpp or Java.
  It is more useful however, because this way, there are no parsing ambiguities.
  \item Apart from \code{while}, there are also \code|for _ in _ {}| (discussed below) and \code|loop {}| (equivalent to \code|while true {}|) as loop constructs.
  \item The feature \enquote{everything is an expression} allows most syntactic elements to be used in places where an expression is expected.
  One example is the assignment on line~22. While this in particular is also possible with the ternary operator \code{?:} in some other languages, Rust allows \code{match} expressions (similar to but more powerful than \code{switch} in \cpp), loops, full blocks and many more constructs in expression context.
  \item The last expression in a function is automatically returned (early returns with \code{return} are still possible).
  This feature is particularly useful in combination with \enquote{everything is an expression}.
  \item By convention, \code{snake_case} is used for functions, methods, variables and modules; \code{UpperCamelCase} for types and traits; \code{SCREAMING_SNAKE_CASE} for constants.
\end{itemize}



\subsubsection*{Types}

\begin{table}[t]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|l|l|l|l|l|l||l||l|}\hline
  \code{i8} & \code{i16} & \code{i32} & \code{i64} & \code{i128} & \code{isize} & \code{f32} & \code{bool} \\\hline
  \code{u8} & \code{u16} & \code{u32} & \code{u64} & \code{u128} & \code{usize} & \code{f64} & \code{char} \\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}
  \caption{
    Rust's primitive types.
    Signed integers use the prefix \codebox{i}, unsigned integers \codebox{u}, floating point numbers \codebox{f}.
    The number in the name specifies the size of the type in bits.
    \codebox{usize} and \codebox{isize} are pointer-sized (64 bits on x86-64) and thus equivalent to \cpp's \codebox{size\_t} and \codebox{ptrdiff\_t}.
    \codebox{char} has a size of 32 bits and represents a \emph{Unicode scalar value}.
  }
  \label{tab:primitive-types}
\end{table}

The core language contains a number of primitive types as shown in table~\ref{tab:primitive-types}.
New types can be created by programmers in mainly two ways: as \code{struct} or as \code{enum}.
Structs are heterogenous product-types  defined by a list of fields and work very similar to structs or classes in \cpp.

Enums, on the other hand, are sum-types -- a feature not offered by most mainstream languages.
While some enum types in Rust are simple \enquote{C-like enums} (just an enumeration of names), each enum \emph{variant} can have arbitrary data associated with it.
In the example below, an instance of type \code{CssColor} is either \code{CssColor::Name} and stores a string, \emph{or} \code{CssColor::Rgb} and stores three \code{u8} values, \emph{or} \code{CssColor::None} and does not store any additional data.
In \cpp, a type like this would be implemented with an integer tag and a \code{union} (which is exactly how this type works at machine level in Rust).

\vspace{-3mm}
\begin{center}
\begin{minipage}[t]{.45\textwidth}
\begin{rustcode}
struct Point {
    x: f32,
    y: f32,
}
\end{rustcode}
\end{minipage}
\begin{minipage}[t]{.45\textwidth}
\begin{rustcode}
enum CssColor {
    Name(String),
    Rgb { r: u8, g: u8, b: u8 },
    None,
}
\end{rustcode}
\end{minipage}
\end{center}

In addition to this, Rust has:
\vspace{-3mm}
\begin{itemize}
  \item Fixed-size arrays \code{[T; N]}: anonymous, homogeneous product-types.
  \item Tuples \code{(T, U, V)}: anonymous, heterogeneous product-types.
  \item References \code{&T} and \code{&mut T} (immutable and mutable): like \cpp references, but are guaranteed to point to a valid instance of \code{T}.
  This guarantee is one of the core features of Rust and is discussed later.
  \item Slices \code{&[T]}: a reference plus length to a contiguous sequence of elements (for example, part of an array or a \code{Vec<T>}).
  \item String slices \code{&str}: like a normal slice, but referencing a UTF-8 encoded string buffer.
\end{itemize}

Crucially important for Rust's performance and suitability as a systems programming language, is the fact that user compound types (like structs or enums) do \emph{not} use automatic boxing.
Instead, all fields are stored inline and are densely packed, as in \cpp or C.
As a consequence, there is virtually no difference between using two \code{f32} variables, one \code{[f32; 2]} variable or one \code{Point} (example code above) variable in a function: all versions will store $2 \cdot 32 = 64$ bits on the stack.

Another notable difference to languages like \cpp or Java is the separation of data and behavior of a type.
The type definition shown above only define the data layout of the type.
To add methods to a type, \code{impl} blocks are used: all functions in an \code{impl} block live in the namespace of that type.
Functions with a special first \code{self} parameter are methods that can be called on an instance of the type with the dot syntax \code{instance.method()}.
\code{self} is the instance of the type and is usually equivalent to \code{this} in \cpp and Java or \code{self} in Python.
Functions without a \code{self} parameter (that are not called on an instance) are so called \emph{associated functions} which are equivalent to \emph{static methods} in \cpp or Java.

A small example based on the \code{Point} definition above:

\playground{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b66020119f65675812d46e3be9e82c2d}

\begin{rustcode}
impl Point {
    fn origin() -> Self {
        Self {
            x: 0.0,
            y: 0.0,
        }
    }

    fn distance_from(&self, other: &Self) -> f32 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }
}

fn main() {
    let a = Point::origin();
    let b = Point { x: 1.0, y: 2.0 };
    println!("{}", a.distance_from(&b));
}
\end{rustcode}

This demonstrates a few additional points:

\vspace{-3mm}
\begin{itemize}
  \item \code{Self} is an alias for the type of the \code{impl} block (\code{Point} in this case).
  \item Structs can be created via the \emph{struct initializer syntax} (see line~3 or 16).
  If the fields are not accessible due to them being private (like \code{Vec}'s fields), an instance can only be created via the associated functions offered by the type (e.\,g. \code{Point::origin} or \code{Vec::new}).
  \item Primitive types can have methods, too.
  Shown here: \code{f32::powi} and \code{f32::sqrt}.
\end{itemize}

Unlike in many garbage collected languages (like Java), values in Rust cannot be \code{null}:
a variable of type \code{T} is always a valid instance of that type; a reference \code{&T} is always a valid reference to a valid instance of type \code{T}.
As such, Rust needs some other way to represent \emph{optional} values and the \emph{absence} of a value.
Used for that purpose is the generic standard library type \code{Option<T>} which is defined as shown in figure~\ref{fig:option-result-def}.
For example, an instance of type \code{Option<String>} is either \code{None} or \code{Some(s)} where \code{s} is a valid string.

\begin{figure}[t]
\centering
\begin{subfigure}{.4\textwidth}
\begin{rustcode}
enum Option<T> {
    Some(T),
    None,
}
\end{rustcode}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
\begin{rustcode}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{rustcode}
\end{subfigure}
\caption{Definition of \codebox{Option<T>} and \codebox{Result<T, E>} in the standard library.}
\label{fig:option-result-def}
\end{figure}

Rust can perform a number of layout optimizations for enums and structs. One of the most important one is the \emph{null pointer optimization} which has the effect that \code{Option<&T>} and \code{&T} have exactly the same size (the size of \code{usize} to be precise). This works for all enums that are defined like \code{Option<T>} (the standard library type is not special) and for all types that never use the bit-pattern 0 (references do not, as they are always valid).

To use a value of type \code{Option<T>}, a programmer has a variety of possibilities. They can use a \code{match} block or use one of \code{Option}'s method, like \code{unwrap_or}: it returns the inner value, if there is one, or a provided default value, if the option was \code{None}.
% TODO: maybe remove the above paragraph

\subsubsection*{Error Handling}

In Rust, errors are logically divided into two kinds: recoverable errors and bugs (or unrecoverable errors).
Errors of the former kind are to be expected and occur because the \enquote{world} is in an erroneous state.
The latter kind of errors are caused by an incorrect program and can usually not be recovered from.

Since these kinds of errors are very different, Rust uses two different strategies to deal with them.
Upon noticing an unrecoverable error, a Rust program \emph{panics}.
A \emph{panic} in Rust immediately aborts the current thread and does a final cleanup by unwinding the stack.
This is Rust's version of \emph{abandonment} as defined in \cite{duffy2016error}.
That resource is also a great introduction to the topic and explains why this categorization into error kinds is useful and why \emph{abandonment} in a bug situation is useful.

Recoverable errors are handled with the \code{Result<T, E>} type which definition can be seen in figure~\ref{fig:option-result-def}.
Functions returning such a type either return successfully with a value \code{Ok(x)} where \code{x} is an instance of type \code{T} or they fail and return \code{Err(e)} where \code{e} is an instance of \code{E}.
This means that Rust uses \emph{return value based} error handling (like C does with returning error codes).
However, in contrast to C-like error codes, with \code{Result}, it is impossible to forget checking if an error has occurred, making this solution far more robust.
The core language makes working with \code{Result}s easier by providing the \code{?} operator which delegates errors to the calling function automatically.



% # traits
% generics
% iterator
% macros
% trait objects
% drop
% (sync & send)

% # Ownership and Borrowing
% aliasing xor mutability
% references always valid
% table showing equivalents of &self, &mut self, self with C++ and Java

\chapter{Background: Rust}

\emph{Rust}\footnote{Website: \url{https://www.rust-lang.org/}} is a general-purpose, open-source systems programming language\footnote{A \enquote{system programming language} is a language that is well suited to build system software, like operating systems, browser engines and device drivers. These language give the programmer low-level access to the computer hardware.} focused on reliability, performance and memory safety.
It is openely developed by the Rust community, with core developers being funded by Mozilla\footnote{Mozilla is mainly known for the browser \emph{Firefox} and its involvement with researching and standardising web-technologies. Website: \url{https://www.mozilla.org}}.
Its first stable version was release in May, 2015.
Since then, a new, fully backwards-compatible version is released every six weeks.
Rust was voted \enquote{most loved programming language} four times in a row from 2015 -- 2019 in the StackOverflow\footnote{A question \& answer website for programmers with over 10 million registered users as of January, 2019 \cite{so-user-count}. Website: \url{https://stackoverflow.com/}} Developer Survey -- one of the largest annual programmer-focussed surveys \cite{so-survey}.

\begin{figure}[h]
  \vspace{5mm}
  \centering
  \includesvg[.68\textwidth]{rust-logo-ferris}
  \caption{The Rust logo (left, \protect\hyperlink{cc-by}{CC-BY 4.0}) and the unofficial mascot of Rust (right, \protect\hyperlink{cc0}{CC0}).}
  \vspace{5mm}
\end{figure}

Rust is categorized as a multi-paradigm programming language; it is mainly imperative and structured, but has many features to allow for different programming paradigms, like functional or declarative programming.
Its design is influenced by many other programming languages, most importantly \cpp, Haskell and OCaml \cite{rust-influences}.
A strong, static type system is at the core of the language, enabling many of Rust's main features (this is explained in more detail below).
Rust is also a cross-platform language, running on different operating systems (including Linux, Windows, macOS, Android and iOS) and different CPU architectures (including x86, ARM, WASM and MIPS) \cite{rust-platforms}.

Rust does not have a \emph{garbage collector} (GC) and is compiled to native machine code in a native executable format.
The code generation is done by LLVM \cite{llvmwebsite, lattner2004llvm}, a collection of libraries and tools related to building compilers.
LLVM is also used by the \cpp compiler \code{clang++}, among others.
Like in \cpp, resource management (including memory management) is handled by the \emph{RAII} idiom \cite{raiihackcraft, stroustrup2001exception}.
This means that resources are released in so called \emph{destructor} functions (called \code{drop} in Rust) which are called automatically if an instance is destroyed (e.\,g. by going out of scope).

An important principle of Rust is the notion of \emph{zero cost abstractions} -- a term coined by \cpp.
As described by Stroustrup: \enquote{\cpp implementations obey the zero-overhead principle: What you don’t use, you don’t pay for [...]. And further: What you do use, you couldn’t hand code any better} \cite{stroustrup2012foundations}.
Due to the focus on making abstractions \emph{zero cost} and LLVM's high-quality code generation, Rust programs achieve execution speeds equivalent to \cpp or C programs (sometimes a bit slower, sometimes a bit faster).

After installing Rust, the command line tools \code{rustc}, \code{cargo} and \code{rustup} (amongst others) are available.
\emph{Cargo} is Rust's dependency manager and build tool which can use the official package repository \url{https://crates.io}.
The ability to easily and reliably include libraries into a project sets Rust apart from most other system programming languages.
\emph{Rustup} is a compiler version manager, which is also used to install additional tools and to setup cross-compilation.

Since Rust's initial release, it has been adopted by more and more programmers.
It is already used in production by hundreds of companies, most notably: Dropbox, NPM, Mozilla, Yelp \cite{rust-production}.

This chapter gives a very quick overview over the parts of Rust most important to this thesis.
To learn more about Rust, a large number of resources are available, including \emph{The Rust Programming Language} \cite{klabnik2018rust} which is available for free at \url{https://doc.rust-lang.org/book/}.
Also worth mentioning is the \enquote{Rust Playground}, an online compiler for quick testing, available at \url{https://play.rust-lang.org/}.
In this chapter, many code snippets contain a link to the playground containing that code (obviously only usable in the digital version of this thesis).


\section{Basic Syntax and Semantics}

The following code snippet (showing a not particularly useful program) demonstrates Rust's basic syntax and many other basic features.
The code is explained in more detail below.

\begin{rustcode*}{linenos, xleftmargin=20pt}
use std::{@\playground{?version=stable&mode=release&edition=2018&gist=06d3e3f17909c9c73cb68f0fbb7956ea}@
    thread,
    time::Duration,
};

fn main() {
    const START: u64 = 871;

    let seq = collatz(START);
    println!("Collatz sequence of {} has a length of {}", START, seq.len());

    thread::sleep(Duration::from_millis(1500));
    println!("Bye!");
}

/// Generates and returns the Collatz sequence starting from `start`,
/// excluding `start` itself.
fn collatz(start: u64) -> Vec<u64> {
    let mut number = start;
    let mut steps = Vec::new();
    while number != 1 {
        number = if number % 2 == 0 { number / 2 } else { number * 3 + 1 };
        steps.push(number);
    }

    steps
}
\end{rustcode*}

Explanations and remarks about the code above:
\vspace{-3mm}
\begin{itemize}
  \item A library in Rust is a single compilation unit, called a \emph{crate}.
  Each crate defines symbols in a module tree.
  Modules are similar to namespaces in \cpp, but the module trees in Rust are often deeper than nested namespaces in \cpp.
  \code{::} is used as separator in paths to symbols (e.\,g. \code{std::time::Duration}).
  With \code{use} (line~1), symbol names can be imported into scope.
  A few very important names (listed in \code{std::prelude}) are always imported.
  \item The keyword \code{fn} defines a function.
  Parameters are listed in the parenthesis after the function name (parameter name and type are flipped compared to \cpp), the return type is specified after \code{->}.
  \item The \code{main} function (line~6) is the entry point of Rust programs.
  \item Variables (more specifically: \emph{variable bindings}) are created with \code{let} (line~9).
  \item Rust is completely statically typed, but very elaborate type inference allows to omit type annotations in many places.
  They are usually only necessary in function signatures, types and \code{const} definitions.
  \item \code{println} (line~10) is a macro which is used for printing to stdout.
  Macros are invoked with the \code{!} after the name and operate on the source code and not on values, which makes them more powerful than normal functions in some situations.
  \item There are no \emph{constructors} in Rust.
  Instead, static methods (called \emph{associated functions} in Rust) returning an instance of the type are used.
  Examples: \code{Duration::from_millis} (line~12) and \code{Vec::new}  (line~20); \code{new} is not a keyword, but simply the function's name.
  \item \code{Vec<T>} is equivalent to \code{std::vector<T>} in \cpp: a growable array with elements of type \code{T}.
  \item Variable bindings are immutable by default.
  The keyword \code{mut} (line~19 and 20) is necessary to make them mutable.
  This is exactly the opposite of the default behavior in languages like \cpp and Java.
  This is useful, because in normal Rust code (unlike in this example), immutable bindings significantly outnumber mutable ones.
  \item In control structures like \code{if} and \code{while}, the boolean expression does not need to be wrapped inside parenthesis \code{()}, but the body always has to be wrapped in braces \code|{}|.
  This is, again, exactly the opposite of the rules in \cpp or Java.
  It is more useful however, because this way, there are no parsing ambiguities.
  \item Apart from \code{while}, there are also \code|for _ in _ {}| (discussed below) and \code|loop {}| (equivalent to \code|while true {}|) as loop constructs.
  \item The feature \enquote{everything is an expression} allows most syntactic elements to be used in places where an expression is expected.
  One example is the assignment on line~22. While this in particular is also possible with the ternary operator \code{?:} in some other languages, Rust allows \code{match} expressions (similar to but more powerful than \code{switch} in \cpp), loops, full blocks and many more constructs in expression context.
  \item The last expression in a function is automatically returned (early returns with \code{return} are still possible).
  This feature is particularly useful in combination with \enquote{everything is an expression}.
  \item By convention, \code{snake_case} is used for functions, methods, variables and modules; \code{UpperCamelCase} for types and traits; \code{SCREAMING_SNAKE_CASE} for constants.
\end{itemize}



\subsubsection*{Types}

\begin{table}[t]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|l|l|l|l|l|l||l||l|}\hline
  \code{i8} & \code{i16} & \code{i32} & \code{i64} & \code{i128} & \code{isize} & \code{f32} & \code{bool} \\\hline
  \code{u8} & \code{u16} & \code{u32} & \code{u64} & \code{u128} & \code{usize} & \code{f64} & \code{char} \\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}
  \caption{
    Rust's primitive types.
    Signed integers use the prefix \codebox{i}, unsigned integers \codebox{u}, floating point numbers \codebox{f}.
    The number in the name specifies the size of the type in bits.
    \codebox{usize} and \codebox{isize} are pointer-sized (64 bits on x86-64) and thus equivalent to \cpp's \codebox{size\_t} and \codebox{ptrdiff\_t}.
    \codebox{char} has a size of 32 bits and represents a \emph{Unicode scalar value}.
  }
  \label{tab:primitive-types}
\end{table}

The core language contains a number of primitive types, shown in table~\ref{tab:primitive-types}.
New types can be created by programmers in mainly two ways: as \code{struct} or as \code{enum}.
Structs are heterogenous product-types  defined by a list of fields and work very similar to structs in~C.

Enums, on the other hand, are sum-types -- a feature not offered by most mainstream languages.
While some enum types in Rust are simple \enquote{C-like enums} (just an enumeration of names), each enum \emph{variant} can have arbitrary data associated with it.
In the example below, an instance of type \code{CssColor} is either \code{CssColor::Name} and stores a string, \emph{or} \code{CssColor::Rgb} and stores three \code{u8} values, \emph{or} \code{CssColor::None} and does not store any additional data.
In \cpp, a type like this would be implemented with an integer tag and a \code{union} (which is exactly how this type works at machine level in Rust).

\vspace{-3mm}
\begin{center}
\begin{minipage}[t]{.45\textwidth}
\begin{rustcode}
struct Point {
    x: f32,
    y: f32,
}
\end{rustcode}
\end{minipage}
\begin{minipage}[t]{.45\textwidth}
\begin{rustcode}
enum CssColor {
    Name(String),
    Rgb { r: u8, g: u8, b: u8 },
    None,
}
\end{rustcode}
\end{minipage}
\end{center}

Rust is not an object-oriented language.
While there are some similarities to object-oriented languages like Java (e.\,g. the \code{instance.method()} call syntax and \emph{encapsulation}), Rust, by design, does not feature inheritance.
Advantages of OOP, like code-reuse and abstraction, are achieved via different means in Rust.

In addition to this, Rust has:
\vspace{-3mm}
\begin{itemize}
  \item Fixed-size arrays \code{[T; N]}: anonymous, homogeneous product-types.
  \item Tuples \code{(T, U, V)}: anonymous, heterogeneous product-types. The empty tuple \code{()} is equivalent to \code{void} in many other languages.
  \item References \code{&T} and \code{&mut T} (immutable and mutable): like \cpp references, but are guaranteed to point to a valid instance of \code{T}.
  This guarantee is one of the core features of Rust and is discussed later.
  \item Slices \code{&[T]}: a reference plus length to a contiguous sequence of elements (for example, part of an array or a \code{Vec<T>}).
  \item String slices \code{&str}: like a normal slice, but referencing a UTF-8 encoded string buffer.
\end{itemize}

Crucially important for Rust's performance and suitability as a systems programming language, is the fact that user compound types (like structs or enums) do \emph{not} use automatic boxing.
Instead, all fields are stored inline and are densely packed, as in \cpp or C.
As a consequence, there is virtually no difference between using two \code{f32} variables, one \code{[f32; 2]} variable or one \code{Point} (example code above) variable in a function: all versions will store $2 \cdot 32 = 64$ bits on the stack.

Another notable difference to languages like \cpp or Java is the separation of data and behavior of a type.
The type definition shown above only define the data layout of the type.
To add methods to a type, \code{impl} blocks are used: all functions in an \code{impl} block live in the namespace of that type.
Functions with a special first \code{self} parameter are methods that can be called on an instance of the type with the dot syntax \code{instance.method()}.
\code{self} is the instance of the type and is usually equivalent to \code{this} in \cpp and Java or \code{self} in Python.
Functions without a \code{self} parameter (that are not called on an instance) are so called \emph{associated functions} which are equivalent to \emph{static methods} in \cpp or Java.

A small example based on the \code{Point} definition above:

\begin{rustcode*}{linenos, xleftmargin=20pt}
impl Point { @\playground{?version=stable&mode=debug&edition=2018&gist=b66020119f65675812d46e3be9e82c2d}@
    fn origin() -> Self {
        Self {
            x: 0.0,
            y: 0.0,
        }
    }

    fn distance_from(&self, other: &Self) -> f32 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }
}

fn main() {
    let a = Point::origin();
    let b = Point { x: 1.0, y: 2.0 };
    println!("{}", a.distance_from(&b));
}
\end{rustcode*}

This demonstrates a few additional points:

\vspace{-3mm}
\begin{itemize}
  \item \code{Self} is an alias for the type of the \code{impl} block (\code{Point} in this case).
  \item Structs can be created via the \emph{struct initializer syntax} (see line~3 or 16).
  If the fields are not accessible due to them being private (like \code{Vec}'s fields), an instance can only be created via the associated functions offered by the type (e.\,g. \code{Point::origin} or \code{Vec::new}).
  \item Primitive types can have methods, too.
  Shown here: \code{f32::powi} and \code{f32::sqrt}.
\end{itemize}

Unlike in many garbage collected languages (like Java), values in Rust cannot be \code{null}:
a variable of type \code{T} is always a valid instance of that type; a reference \code{&T} is always a valid reference to a valid instance of type \code{T}.
As such, Rust needs some other way to represent \emph{optional} values and the \emph{absence} of a value.
Used for that purpose is the generic standard library type \code{Option<T>} which is defined as shown in figure~\ref{fig:option-result-def}.
For example, an instance of type \code{Option<String>} is either \code{None} or \code{Some(s)} where \code{s} is a valid string.

\begin{figure}[t]
\centering
\begin{subfigure}{.4\textwidth}
\begin{rustcode}
enum Option<T> {
    Some(T),
    None,
}
\end{rustcode}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
\begin{rustcode}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{rustcode}
\end{subfigure}
\caption{Definition of \codebox{Option<T>} and \codebox{Result<T, E>} in the standard library.}
\label{fig:option-result-def}
\end{figure}

Rust can perform a number of layout optimizations for enums and structs. One of the most important one is the \emph{null pointer optimization} which has the effect that \code{Option<&T>} and \code{&T} have exactly the same size (the size of \code{usize} to be precise). This works for all enums that are defined like \code{Option<T>} (the standard library type is not special) and for all types that never use the bit-pattern 0 (references do not, as they are always valid).

To use a value of type \code{Option<T>}, a programmer has a variety of possibilities. They can use a \code{match} block or use one of \code{Option}'s method, like \code{unwrap_or}: it returns the inner value, if there is one, or a provided default value, if the option was \code{None}.
% TODO: maybe remove the above paragraph

\subsubsection*{Error Handling}

In Rust, errors are logically divided into two kinds: recoverable errors and bugs (or unrecoverable errors).
Errors of the former kind are to be expected and occur because the \enquote{world} is in an erroneous state.
The latter kind of errors are caused by an incorrect program and can usually not be recovered from.

Since these kinds of errors are very different, Rust uses two different strategies to deal with them.
Upon noticing an unrecoverable error, a Rust program \emph{panics}.
A \emph{panic} in Rust immediately aborts the current thread and does a final cleanup by unwinding the stack.
This is Rust's version of \emph{abandonment} as defined in \cite{duffy2016error}.
That resource is also a great introduction to the topic and explains why this categorization into error kinds is useful and why \emph{abandonment} in a bug situation is useful.

Recoverable errors are handled with the \code{Result<T, E>} type which definition can be seen in figure~\ref{fig:option-result-def}.
Functions returning such a type either return successfully with a value \code{Ok(x)} where \code{x} is an instance of type \code{T} or they fail and return \code{Err(e)} where \code{e} is an instance of \code{E}.
This means that Rust uses \emph{return value based} error handling (like C does with returning error codes).
However, in contrast to C-like error codes, with \code{Result}, it is impossible to forget checking if an error has occurred, making this solution far more robust.
The core language makes working with \code{Result}s easier by providing the \code{?} operator which delegates errors to the calling function automatically.


\section{Traits}

Rust supports generic programming, meaning that types and functions can be defined by using type parameters instead of specific types.
A few examples of generic types, like \code{Vec<T>} and \code{Option<T>}, were already mentioned above.
When introducing a type parameter, a programmer cannot assume anything about it (except that its size is known at compile time and thus that an instance of that type can be stored on the stack).

See figure~\ref{fig:clamp} for example.
It shows a function, generic over \code{T}, that returns a value clamped into the range defined by \code{min} and \code{max}.
The code as shown does not compile, because it cannot be assumed that two instances of type \code{T} can be compared via \code{<} or \code{>}.
To fix the problem, the function must declare its requirements on \code{T}, which is done via so called \emph{trait bounds}.
In this particular instance, it is sufficient to change the function signature to \code{fn clamp<T: PartialOrd>}, adding a bound for the trait \code{PartialOrd}.

\begin{figure}[h]
  \centering
  \begin{minipage}[t]{.55\textwidth}
    \begin{rustcode}
      fn clamp<T>(v: T, min: T, max: T) -> T {
          if v < min {
              min
          } else if v > max {
              max
          } else {
              v
          }
      }
    \end{rustcode}
  \end{minipage}
  \hspace{2mm}
  \begin{minipage}[t]{.42\textwidth}
    \footnotesize
    \vspace{3mm}
    \begin{verbatim}
error[E0369]: binary operation `<` cannot
              be applied to type `T`
 --> src/lib.rs:2:8
  |
2 |     if v < min {
  |        ^^^^^^^
  |
  = note: `T` might need a bound for
          `std::cmp::PartialOrd`
    \end{verbatim}
  \end{minipage}
  \caption{
    An incorrectly defined generic function (left) and the corresponding error message by the compiler (right).
  }
  \label{fig:clamp}
\end{figure}

A \emph{trait} defines an interface: it describes functionality without providing that functionality itself.
A trait definition contains a number of items (usually methods) whose signatures are specified, but which are usually lacking an implementation (e.\,g. a method body).
A trait can be implemented by multiple types and each type can implement multiple traits.
This is done with an \code{impl Trait for Type} block.
The \code{impl} block then needs to implement all trait items, i.\,e. provide the actual functionality.
See figure~\ref{fig:shapes} for an example.

% See figure~\ref{fig:trait-examples} for some example traits from the standard library.

% \begin{figure}[ht]
%   \centering
%   \begin{minipage}[t]{.4\textwidth}
%     \begin{rustcode}
%     trait Clone {
%         fn clone(&self) -> Self;
%     }
%     \end{rustcode}
%   \end{minipage}
%   \begin{minipage}[t]{.5\textwidth}
%     \begin{rustcode}
%     trait Write {
%         fn write(&mut self, buf: &[u8])
%             -> Result<usize, io::Error>;
%     }
%     \end{rustcode}
%   \end{minipage}
%   \caption{
%     Two (slightly simplified) example traits from the standard library.
%     \codebox{Clone} is implemented by all types that can clone (duplicate) their instances.
%     \codebox{Write} abstracts over types that can accept and write raw data (like files, stdout or TCP-streams).
%   }
%   \label{fig:trait-examples}
% \end{figure}


\begin{figure}[t]
  \centering
  \begin{minipage}{.65\textwidth}
    \begin{rustcode}
    trait Shape {@\playground{?version=stable&mode=debug&edition=2018&gist=7fd9940f9142b70ceed5d35b9ac989d3}@
        fn area(&self) -> f32;
    }
    \end{rustcode}
    \end{minipage}

    \vspace{3mm}

    \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
    struct Circle {
        radius: f32,
        center: Point,
    }

    impl Shape for Circle {
        fn area(&self) -> f32 {
            self.radius.powi(2) * PI
        }
    }
    \end{rustcode}
  \end{minipage}
  \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
    struct Square {
        side_length: f32,
        center: Point,
    }

    impl Shape for Square {
        fn area(&self) -> f32 {
            self.side_length.powi(2)
        }
    }
    \end{rustcode}
  \end{minipage}
  \caption{Example trait with two example implementations.}
  \label{fig:shapes}
\end{figure}

Traits are used by many other Rust features, including operator overloading (e.\,g. the \code{PartialOrd} trait mentioned above), destructors (the \code{Drop} trait) and closures.
Particularly interesting are the \code{Send} and \code{Sync} traits which form the foundation for memory safe concurrency (i.\,e. no data races).

Traits can be used in two ways: statically and dynamically dispatched.
The kind of dispatch is not specified in the trait definition, but in how the trait is used.
This means that a single trait can be used with dynamic dispatch in one situation and with static dispatch in another.
An example of the two types of usage can be seen in figure~\ref{fig:dispatch}.

\begin{figure}[b]
  \centering
    \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
      fn print_area<S: Shape>(shape: &S) {
          println!("{}", shape.area());
      }
    \end{rustcode}
  \end{minipage}
  \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
      fn print_area(shape: &dyn Shape) {
          println!("{}", shape.area());
      }
    \end{rustcode}
  \end{minipage}
  \caption{
    The two types of dispatch.
    On the left, static dispatch is used (via type parameter with trait bound).
    On the right, dynamic dispatch is used (via trait object).
  }
  \label{fig:dispatch}
\end{figure}

With static dispatch, a new copy of the generic item is made for each way it is instantiated.
Calling the statically dispatched version of \code{print_area} twice, once with a \code{Circle} and once with a \code{Square}, is equivalent to having defined \code{print_area} twice (once for \code{Circle} and once for \code{Square}).
This process is also called \emph{monomorphization} and is used when instantiating \cpp templates.
Dynamic dispatch, on the other hand, uses \emph{vtables} and dynamic/virtual calls.
\cpp's virtual methods and most object-oriented languages use dynamic dispatch.

The main advantage of monomorphization over dynamic dispatch is execution speed.
With static dispatch, the compiler has full knowledge about the type and method body and is thus able to optimize the generated code very well.
With \emph{inlining}, the optimizer is often able to completely remove the call to the trait method, making the usage of traits completely zero-overhead.
This is the main reason for how Rust can achieve \emph{zero cost abstractions}.

An extreme case of good optimization due to static dispatch is the \code{Iterator} trait.
An iterator is simply a sequence of items of a specific type.
The trait features a variety of different helper methods -- called \emph{iterator adaptors} -- which can be used to create a new iterator from an existing ones.
For example, \code{1..8} is the Rust syntax for a range and represents an iterator over integers: 1, 2, 3, 4, 5, 6, 7 (the upper limit is exclusive).
We can create a new iterator by filtering the existing one to remove some elements: \code{(1..8).filter(|&x| x % 2 == 0)}.
This expression is an iterator over the items 2, 4, 6.
Taking this further, with \code{map}, we can change each item to something else.
\code{(1..8).filter(|&x| x % 2 == 0).map(|x| x * x)} is an iterator over the items 4, 16, 36.

While this high-level programming looks like it involves many method calls, iterator chains like this compile down to almost optimal machine code most of the time.


\section{Ownership and Borrowing}

In order to guarantee memory safety and robustness, Rust uses a few concepts not found in most other languages.
One such concept is \emph{ownership}.

Different languages have different \emph{default assignment semantics}, in other words: they differ in what happens when assigning one value to another.
In Java and many other garbage collected languages, \emph{share semantics} are used by default.
That means that, if there is a collection \code{a} and the line \code{Collection b = a;} is executed, \code{b} is now a reference to the original collection (i.\,e. \code{a} and \code{b} reference the same collection).
\cpp on the other hand, defaults to \emph{copy semantics}.
In \cpp, \code{b} would be an exact (usually deep) copy of \code{a}; changing \code{b} would not influence \code{a}.

Rust uses neither of those solutions: referencing a value requires taking a reference to it explicitly; cloning a value also requires an explicit call to \code{clone()}.
Instead, Rust uses \emph{move semantics}.
In Rust, the original collection can be accessed through the variable \code{b} and the variable \code{a} is not usable anymore.
The latter is checked by the compiler and compilation will fail with an error when a moved value is accessed (see figure~\ref{fig:string-move}).


\begin{figure}[b]
  \centering
  \begin{minipage}[t]{.5\textwidth}
    \begin{rustcode}
      @\playground{?version=stable&mode=debug&edition=2018&gist=e367f6069e48d4c2a7306479217af34c}@
      fn main() {
          let a = String::from("hello");
          let b = a;
          println!("{}", b);
          println!("{}", a);
      }
    \end{rustcode}
  \end{minipage}
  \hspace{2mm}
  \begin{minipage}[t]{.47\textwidth}
    \footnotesize
    \vspace{3mm}
    \begin{verbatim}
error[E0382]: borrow of moved value: `a`
 --> src/main.rs:5:20
  |
2 |     let a = String::from("hello");
3 |     let b = a;
  |             - value moved here
4 |     println!("{}", b);
5 |     println!("{}", a);
  |                    ^ value borrowed here
    \end{verbatim}
  \end{minipage}
  \caption{Attempting to use a value that has been moved results in a compiler error.}
  \label{fig:string-move}
\end{figure}

Optional move semantics have been introduced in \cppeleven, but they are not as secure as in Rust.
For example, the \cpp compiler does not raise an error when the programmer accesses the variable that was moved from, although this is usually unsafe.

There is one notable exception to Rust's move semantics: types that implement the trait \code{Copy} use copy semantics.
That trait is only implemented by types that can be correctly cloned by simply copying the bits of the type (i.\,e. the bits on the stack).
For example, \code{Vec<T>} cannot implement that trait, because it consists of a pointer to data; simply copying the pointer without copying the buffer behind that pointer would mean that two instances of \code{Vec<T>} think they own a buffer, leading to a double free when the destructor of the two instances is called.
All primitive types implement \code{Copy}, but user-defined types can also implement it, as long as all their fields implement the trait, too.

% TODO: maybe remove this table
\begin{table}[ht]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|l|l|l|l|}\hline
    \textbf{Rust} & \textbf{\cpp} & \textbf{Java} \\\hline
    \code{fn foo()} & \code{static void foo()} & \code{static void foo()}\\\hline
    \code{fn foo(&self)} & \code{void foo() const} & \emph{not possible}\\\hline
    \code{fn foo(&mut self)} & \code{void foo()} & \code{void foo()}\\\hline
    \code{fn foo(self)} & \code{void foo() &&} & \emph{not possible}\\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1}
  \caption{Comparison of different types of methods across different languages.}
  \label{tbl:receiver-obj}
\end{table}

The concept \emph{borrowing} is related to references.
In Rust, taking the reference of a value is also called \enquote{borrowing that value} and during the time a reference to a value exists, that value is said to be \enquote{borrowed}.
There are immutable (\code{&T}) and mutable borrows (\code{&mut T}).

There is one crucially important rule regarding the use of references: \textbf{at any point in time, each value can \emph{either} be referenced by any number of immutable references \emph{or} by exactly one mutable reference}.
This is also called \emph{Aliasing xor Mutability} (although \emph{nand} would technically be more correct).
This means that there cannot exist a mutable and an immutable reference to the same value at the same time.
Like the ownership analysis mentioned above, this rules is also entirely enforced at compile time; Rust references compile down to simple pointers.

This restriction might initially sound too strict, but there are good reasons why it is a good idea.
Figure~\ref{fig:vector-bad} illustrates one reason.
In practice, this rule is not as problematic as one might assume.
In only a very few situations, it is necessary work around this problem, which can be done in a variety of ways.
One notable \enquote{escape hatch} is called \emph{interior mutability}, which describes the ability to mutate some data through a \code{&T} reference.
This is only possible via carefully designed interface, like the type \code{Mutex} from the standard library.

\begin{figure}[b]
  \centering
    \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
      let mut v = vec![5, 6];
      let a = &v[0];
      v.push(7);
      println!("{}", a);
    \end{rustcode}
  \end{minipage}
  \begin{minipage}[t]{.49\textwidth}
    \begin{cppcode}
      auto v = vector<int>{5, 6};
      const auto& a = v[0];
      v.push_back(7);
      cout << a << endl;
    \end{cppcode}
  \end{minipage}
  \caption{
    A classical example of why mutability with aliasing can easily lead to memory unsafety.
    The \codebox{push}/\codebox{push\_back} might trigger an internal reallocation which would invalidate the reference \codebox{a}.
    The Rust version does not compile due to the \emph{aliasing xor mutability} rule, while the \cpp version compiles fine but exhibits \emph{undefined behavior} due to memory unsafety when executing.
  }
  \label{fig:vector-bad}
\end{figure}

Finally, due to compile-time lifetime-tracking, the compiler can make sure that references never outlive the value they are referencing.
Thus, references always point to valid objects.
It is possible, and sometimes necessary, for the programmer to explicitly annotate lifetimes on function signatures, but as this is not important to understanding this thesis, it will not be explained here.

While Rust can almost always prove the memory-safety of a program, in some rare cases, it is necessary to write code outside of the compiler's protection.
For that reason, Rust offers \code{unsafe} blocks.
Within such a block, the programmer can work with raw pointers and do a few other things that are not allowed outside of an \code{unsafe} block.
But again, using \code{unsafe} is not necessary in the vast majority of Rust code.
It is actually considered bad style to use \code{unsafe} code where it can be avoided.
Almost all \code{unsafe} code is hidden behind safe interfaces; so while building blocks like \code{Vec<T>} and \code{Mutex<T>} cannot be efficiently implemented without \code{unsafe} code, users can use their safe interface without needing to worry about memory safety.

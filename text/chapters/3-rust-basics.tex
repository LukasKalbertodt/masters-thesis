\chapter{Background: Rust}

\emph{Rust}\footnote{Website: \url{https://www.rust-lang.org/}} is a general-purpose, open-source systems programming language\footnote{A \enquote{system programming language} is a language that is well suited to build system software, like operating systems, browser engines and device drivers. These languages give the programmer low-level access to the computer hardware.} focused on reliability, performance and memory safety.
It is openly developed by the Rust community, with core developers being funded by Mozilla\footnote{Mozilla is mainly known for the browser \emph{Firefox} and its involvement with researching and standardizing web-technologies. Website: \url{https://www.mozilla.org}}.
Its first stable version was released in May 2015.
Since then, a new, fully backwards-compatible version is released every six weeks.
Rust was voted \enquote{most loved programming language} four times in a row from 2015 to 2019 in the StackOverflow\footnote{A question \& answer website for programmers with over 10 million registered users as of January 2019 \cite{so-user-count}. Website: \url{https://stackoverflow.com/}} Developer Survey -- one of the largest annual programmer-focussed surveys \cite{so-survey}.

\begin{figure}[h]
  \vspace{5mm}
  \centering
  \includesvg[.68\textwidth]{rust-logo-ferris}
  \caption{The Rust logo (left, \protect\hyperlink{cc-by}{CC-BY 4.0}) and the unofficial mascot of Rust (right, \protect\hyperlink{cc0}{CC0}).}
  \vspace{5mm}
\end{figure}

Rust is categorized as a multi-paradigm programming language; it is mainly imperative and structured, but has many features to allow for different programming paradigms, like functional or declarative programming.
Its design is influenced by many other programming languages, most importantly \cpp, Haskell and OCaml \cite{rust-influences}.
A strong, static type system is at the core of the language, enabling many of Rust's main features.
It will be explained in more detail below.
Rust is also a cross-platform language, running on different operating systems (including Linux, Windows, macOS, Android and iOS) and different CPU architectures (including x86, ARM, WASM and MIPS) \cite{rust-platforms}.

Rust does not have a \emph{garbage collector} (GC) and is compiled to native machine code in the operating system's executable format.
The code generation is done by LLVM \cite{llvmwebsite, lattner2004llvm}, a collection of libraries and tools related to building compilers.
It is also used by the \cpp compiler \code{clang++}, among others.
Like in \cpp, resource management (including memory management) is handled by the \emph{RAII} idiom \cite{raiihackcraft, stroustrup2001exception}.
This means that resources are released in so called \emph{destructor} functions (called \code{drop} in Rust) which are called automatically if an instance is destroyed (e.\,g. by going out of scope).

An important principle of Rust is the notion of \emph{zero cost abstractions} -- a term coined by \cpp.
As described by Stroustrup: \enquote{\cpp implementations obey the zero-overhead principle: What you don’t use, you don’t pay for [...]. And further: What you do use, you couldn’t hand code any better} \cite{stroustrup2012foundations}.
Due to the focus on making abstractions \emph{zero cost} and LLVM's high-quality code generation, Rust programs achieve execution speeds equivalent to \cpp or C programs \cite{benchmarkgame}.

After installing Rust, the command line tools \code{rustc}, \code{cargo} and \code{rustup} (amongst others) are available.
\emph{Cargo} is Rust's dependency manager and build tool which can use the official package repository \url{https://crates.io}.
The ability to easily and reliably include libraries into a project sets Rust apart from most other systems programming languages.
Lastly, \emph{rustup} is a compiler version manager, which is also used to install additional tools and to set up cross-compilation.

Since Rust's initial release, it has been adopted by more and more programmers.
It is already used in production by hundreds of companies, most notably Dropbox, Microsoft, NPM, Mozilla, and Yelp \cite{rust-production}.

This chapter gives a very quick overview over the language.
To learn more about Rust, numerous resources are available, including \emph{The Rust Programming Language} \cite{klabnik2018rust} which is available for free at \url{https://doc.rust-lang.org/book/}.
The \enquote{Rust Playground} is a very handy online compiler available at \url{https://play.rust-lang.org/}.
In this chapter, many code snippets contain a link to the playground containing that code (only usable in the digital version of this thesis).

\vspace{5mm}
\section{Basic Syntax and Semantics}

The following code snippet (showing a not particularly useful program) demonstrates Rust's basic syntax and many other basic features.
The code is explained in more detail below.

\begin{rustcode*}{linenos, xleftmargin=20pt}
use std::{@\playground{?version=stable&mode=release&edition=2018&gist=06d3e3f17909c9c73cb68f0fbb7956ea}@
    thread,
    time::Duration,
};

fn main() {
    const START: u64 = 871;

    let seq = collatz(START);
    println!("Collatz sequence of {} has a length of {}", START, seq.len());

    thread::sleep(Duration::from_millis(1500));
    println!("Bye!");
}

/// Generates and returns the Collatz sequence starting from `start`,
/// excluding `start` itself.
fn collatz(start: u64) -> Vec<u64> {
    let mut number = start;
    let mut steps = Vec::new();
    while number != 1 {
        number = if number % 2 == 0 { number / 2 } else { number * 3 + 1 };
        steps.push(number);
    }

    steps
}
\end{rustcode*}

\vspace{-1mm}
Some explanations and remarks to the code above:

\vspace{-2mm}
\begin{itemize}
  \item A library in Rust is a single compilation unit, called a \emph{crate}.
  Each crate defines symbols in a module tree.
  Modules are similar to namespaces in \cpp, but the module trees in Rust are often deeper than nested namespaces in \cpp.
  The punctuation \code{::} is used as separator in paths to symbols (e.\,g. \code{std::time::Duration}).
  With \code{use} (line~1), symbol names can be imported into scope.
  A few very important names (listed in \code{std::prelude}) are always imported.
  \item The keyword \code{fn} defines a function.
  Parameters are listed in the parentheses after the function name (parameter name and type are swapped compared to \cpp), the return type is specified after \code{->}.
  \item The \code{main} function (line~6) is the entry point of Rust programs.
  \item Variables (more precisely: \emph{variable bindings}) are created with \code{let} (line~9).
  \item Rust is completely statically typed, but very elaborate type inference allows omitting type annotations in many places.
  They are usually only necessary in function signatures, types and \code{const} definitions.
  \item \code{println} (line~10) is a macro which is used for printing to stdout.
  Macros are invoked with the \code{!} after the name and operate on the source code and not on values, which makes them more powerful than normal functions in some situations.
  \item There are no \emph{constructors} in Rust.
  Instead, static methods (called \emph{associated functions} in Rust) returning an instance of the type are used.
  Examples: \code{Duration::from_millis} (line~12) and \code{Vec::new}  (line~20); \code{new} is not a keyword, but simply the function's name.
  \item \code{Vec<T>} is equivalent to \cpp's \code{vector<T>}: a growable array with elements of type \code{T}.
  \item Variable bindings are immutable by default.
  The keyword \code{mut} (line~19 and 20) is necessary to make them mutable.
  This is exactly the opposite of the default behavior in languages like \cpp and Java.
  This is useful, because in normal Rust code (unlike in this example), immutable bindings significantly outnumber mutable ones.
  \item In control structures like \code{if} and \code{while}, the boolean expression does not need to be wrapped inside parentheses \code{()}, but the body always has to be wrapped in braces \code|{}|.
  This is, again, exactly the opposite of the rules in \cpp or Java.
  Rust' syntax is more useful however, because this way, there are no parsing ambiguities.
  \item Apart from \code{while}, there are also \code|for _ in _ {}| (using iterators) and \code|loop {}| (equivalent to \code|while true {}|) as loop constructs.
  \item The principle \enquote{everything is an expression} allows most syntactic elements to be used in places where an expression is expected.
  One example is the assignment on line~22. While this in particular is also possible with the ternary operator \code{?:} in some other languages, Rust allows \code{match} expressions (similar to but more powerful than \code{switch} in \cpp), loops, full blocks and many more constructs in expression context.
  \item The last expression in a function is automatically returned (early returns with \code{return} are still possible).
  This feature is particularly useful in combination with \enquote{everything is an expression}.
  \item By convention, \code{snake_case} is used for functions, methods, variables and modules; \code{UpperCamelCase} for types and traits; \code{SCREAMING_SNAKE_CASE} for constants.
\end{itemize}


\vfill
\subsubsection*{Types}

\begin{table}[t]
  \centering
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|l|l|l|l|l|l||l||l|}\hline
  \code{i8} & \code{i16} & \code{i32} & \code{i64} & \code{i128} & \code{isize} & \code{f32} & \code{bool} \\\hline
  \code{u8} & \code{u16} & \code{u32} & \code{u64} & \code{u128} & \code{usize} & \code{f64} & \code{char} \\\hline
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}
  \caption{
    Rust's primitive types.
    Signed integers use the prefix \codebox{i}, unsigned integers \codebox{u}, floating-point numbers \codebox{f}.
    The number in the name specifies the size of the type in bits.
    \codebox{usize} and \codebox{isize} are pointer-sized (64 bits on x86-64) and thus equivalent to \cpp's \codebox{size\_t} and \codebox{ptrdiff\_t}.
    \codebox{char} has a size of 32 bits and represents a \emph{Unicode scalar value}.
  }
  \label{tab:primitive-types}
\end{table}

The core language contains a number of primitive types, shown in table~\ref{tab:primitive-types}.
New types can be created by programmers mainly in two ways: as \code{struct} or as \code{enum}.
Structs are heterogeneous product-types defined by a list of fields and work very similar to structs in~C.

Enums, on the other hand, are sum-types -- a feature not offered by most mainstream languages.
While some enum types in Rust are simple \enquote{C-like enums} (just an enumeration of names), each enum \emph{variant} can have arbitrary data associated with it.
In the example below, an instance of type \code{CssColor} is either \code{CssColor::Name} and stores a string, \emph{or} \code{CssColor::Rgb} and stores three \code{u8} values, \emph{or} \code{CssColor::None} and does not store any additional data.
In C, a type like this would be implemented with an integer tag and a \code{union} (which is exactly how this type works at machine level in Rust).

\vspace{-3mm}
\begin{center}
\begin{minipage}[t]{.45\textwidth}
\begin{rustcode}
struct Point {
    x: f32,
    y: f32,
}
\end{rustcode}
\end{minipage}
\begin{minipage}[t]{.45\textwidth}
\begin{rustcode}
enum CssColor {
    Name(String),
    Rgb { r: u8, g: u8, b: u8 },
    None,
}
\end{rustcode}
\end{minipage}
\end{center}

As a side note: Rust is not an object-oriented language.
While there are some similarities to object-oriented languages like Java (e.\,g. the \code{instance.method()} call syntax and \emph{encapsulation}), Rust, by design, does not feature inheritance.
Advantages of OOP, like code-reuse and abstraction, are achieved via different means in Rust.

\newpage
Rust also offers the following types and kinds of types:
\vspace{-3mm}
\begin{itemize}
  \item Fixed-size arrays \code{[T; N]}: anonymous, homogeneous product-types.
  \item Tuples \code{(T, U, V)}: anonymous, heterogeneous product-types. The empty tuple \code{()} is equivalent to \code{void} in many other languages.
  \item References \code{&T} and \code{&mut T} (immutable and mutable): like \cpp references, but are guaranteed to point to a valid instance of \code{T}.
  This guarantee is one of the core features of Rust and is discussed later.
  \item Slices \code{&[T]}: a reference plus length to a contiguous sequence of elements (for example, part of an array or a \code{Vec<T>}).
  \item String slices \code{&str}: like a normal slice, but referencing a UTF-8 encoded string buffer.
\end{itemize}

Crucially important for Rust's performance and suitability as a systems programming language is the fact that user-defined compound types (like structs or enums) do \emph{not} use automatic boxing.
Instead, all fields are stored inline and are densely packed, like in \cpp or C.
As a consequence, there is virtually no difference between using two \code{f32} variables, one \code{[f32; 2]} variable or one \code{Point} (example code above) variable in a function: all versions will store $2 \cdot 32 = 64$ bits on the stack.

Another notable difference to languages like \cpp or Java is the separation of data and behavior of a type.
The type definition shown above only defines the data layout of the type.
To add methods to a type, \code{impl} blocks are used: all functions in an \code{impl} block live in the namespace of that type.
Functions with a special first \code{self} parameter are methods that can be called on an instance of the type with the dot syntax \code{instance.method()}.
\code{self} is the instance of the type and is usually equivalent to \code{this} in \cpp and Java or \code{self} in Python.
Functions without a \code{self} parameter (that are not called on an instance) are so called \emph{associated functions} which are equivalent to \emph{static methods} in \cpp or Java.

A small example based on the \code{Point} definition above:

\begin{rustcode*}{linenos, xleftmargin=20pt}
impl Point { @\playground{?version=stable&mode=debug&edition=2018&gist=b66020119f65675812d46e3be9e82c2d}@
    fn origin() -> Self {
        Self {
            x: 0.0,
            y: 0.0,
        }
    }

    fn distance_from(&self, other: &Self) -> f32 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }
}

fn main() {
    let a = Point::origin();
    let b = Point { x: 1.0, y: 2.0 };
    println!("{}", a.distance_from(&b));
}
\end{rustcode*}

This demonstrates a few additional points:

\vspace{-3mm}
\begin{itemize}
  \item \code{Self} is an alias for the type of the \code{impl} block (\code{Point} in this case).
  \item Structs can be created via the \emph{struct initializer syntax} (see line~3 or 16).
  If the fields are not accessible due to them being private (like \code{Vec}'s fields), an instance can only be created via the associated functions offered by the type (e.\,g. \code{Point::origin} or \code{Vec::new}).
  \item Primitive types can have methods, too, as shown here: \code{f32::powi} and \code{f32::sqrt}.
\end{itemize}

Unlike in many garbage-collected languages (like Java), values in Rust cannot be \code{null}:
a variable of type \code{T} is always a valid instance of that type; a reference \code{&T} is always a valid reference to a valid instance of type \code{T}.
As such, Rust needs some other way to represent \emph{optional} values/the \emph{absence} of a value.
The generic type \code{Option<T>} from the standard library, defined as shown in figure~\ref{fig:option-result-def}, is used for exactly that purpose.
For example, an instance of type \code{Option<String>} is either \code{None} or \code{Some(s)} where \code{s} is a valid string.

\begin{figure}[b]
\centering
\begin{subfigure}{.4\textwidth}
\begin{rustcode}
enum Option<T> {
    Some(T),
    None,
}
\end{rustcode}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
\begin{rustcode}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{rustcode}
\end{subfigure}
\caption{Definition of \codebox{Option<T>} and \codebox{Result<T, E>} in the standard library.}
\label{fig:option-result-def}
\end{figure}

Rust can perform a number of layout optimizations for enums and structs.
One of the most important ones is the \emph{null pointer optimization} which has the effect that \code{Option<&T>} and \code{&T} have exactly the same size (the size of \code{usize} to be precise).
This works for all enums that are defined like \code{Option<T>} (the standard library type is not special) and for all types that never use the bit-pattern 0 (references do not, as they are always valid).


\subsubsection*{Error Handling}

In Rust, errors are logically divided into two kinds: recoverable errors and bugs (unrecoverable errors).
Errors of the former kind are to be expected and occur because the \enquote{world} is in an erroneous state.
The latter kind of errors are caused by an incorrect program and can usually not be recovered from.

Since these kinds of errors are very different, Rust uses two different strategies to deal with them.
Upon noticing an unrecoverable error, a Rust program \emph{panics}.
A \emph{panic} in Rust immediately aborts the current thread and does a final cleanup by unwinding the stack.
This is Rust's version of \emph{abandonment} as defined in \cite{duffy2016error}.
(That citation is also a great introduction to the topic and explains why this categorization into error kinds is useful and why \emph{abandonment} in a bug situation is useful).

Recoverable errors are handled with the \code{Result<T, E>} type the definition of which can be seen in figure~\ref{fig:option-result-def}.
Functions returning such a type either return successfully with a value \code{Ok(x)} where \code{x} is an instance of type \code{T}, or they fail and return \code{Err(e)} where \code{e} is an instance of \code{E}.
This means that Rust uses \emph{return value based} error handling (like C does with returning error codes).
However, in contrast to C-like error codes, with \code{Result}, it is impossible to forget to check if an error has occurred, making this solution far more robust.
The core language makes working with \code{Result}s easier by providing the \code{?} operator which delegates errors to the calling function automatically.

\vfill
\section{Traits}

Rust supports generic programming, meaning that types and functions can be defined by using type parameters instead of specific types.
A few examples of generic types, like \code{Vec<T>} and \code{Option<T>}, were already mentioned above.
When introducing a type parameter, the programmer cannot assume anything about it (except that its size is known at compile time and thus that an instance of that type can be stored on the stack).

See for example figure~\ref{fig:clamp}:
It shows a function, generic over \code{T}, that returns a value clamped into the range defined by \code{min} and \code{max}.
The code as shown does not compile, because it cannot be assumed that two instances of type \code{T} can be compared via \code{<} or \code{>}.
To fix the problem, the function must declare its requirements on \code{T}, which is done via so called \emph{trait bounds}.
In this particular instance, it is sufficient to change the generic type declaration to \code{<T: PartialOrd>}, adding a bound for the trait \code{PartialOrd}.

\vspace{6mm}
\begin{figure}[h]
  \centering
  \begin{minipage}[t]{.55\textwidth}
    \begin{rustcode}
      fn clamp<T>(v: T, min: T, max: T) -> T {
          if v < min {
              min
          } else if v > max {
              max
          } else {
              v
          }
      }
    \end{rustcode}
  \end{minipage}
  \hspace{2mm}
  \begin{minipage}[t]{.42\textwidth}
    \footnotesize
    \vspace{3mm}
    \begin{verbatim}
error[E0369]: binary operation `<` cannot
              be applied to type `T`
 --> src/lib.rs:2:8
  |
2 |     if v < min {
  |        ^^^^^^^
  |
  = note: `T` might need a bound for
          `std::cmp::PartialOrd`
    \end{verbatim}
  \end{minipage}
  \caption{
    An incorrectly defined generic function (left) and the corresponding error message by the compiler (right).
    Here, like in many other cases, the suggestion of the compiler is sufficient to solve the problem.
  }
  \label{fig:clamp}
\end{figure}
\vspace{6mm}

To declare requirements on a type parameter via a trait bound, those requirements first need to be defined -- which is done via \emph{traits}.
A trait is a kind of interface: it describes functionality without providing that functionality itself.
The definition of a trait contains a number of items (usually methods) whose signatures are specified, but which are usually lacking an implementation (e.\,g. a method body).
A trait can be implemented by multiple types and each type can implement multiple traits.
This is done with an \code{impl Trait for Type} block, in which all trait items need to be implemented, i.\,e. provided with a body.
See figure~\ref{fig:shapes} for a simple example.

\newpage

\begin{figure}[t]
  \centering
  \begin{minipage}{.65\textwidth}
    \begin{rustcode}
    trait Shape {@\playground{?version=stable&mode=debug&edition=2018&gist=7fd9940f9142b70ceed5d35b9ac989d3}@
        fn area(&self) -> f32;
    }
    \end{rustcode}
    \end{minipage}

    \vspace{3mm}

    \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
    struct Circle {
        radius: f32,
        center: Point,
    }

    impl Shape for Circle {
        fn area(&self) -> f32 {
            self.radius.powi(2) * PI
        }
    }
    \end{rustcode}
  \end{minipage}
  \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
    struct Square {
        side_length: f32,
        center: Point,
    }

    impl Shape for Square {
        fn area(&self) -> f32 {
            self.side_length.powi(2)
        }
    }
    \end{rustcode}
  \end{minipage}
  \caption{Example trait with two example implementations.}
  \label{fig:shapes}
  \vspace{5mm}
\end{figure}

Apart from methods and functions, traits can contain associated types and constants, which allow the implementing type to specify a type or a constant value, respectively.
See figure~\ref{fig:associated-type-const} for two examples.
Additionally, the trait itself can already provide default implementations for its items, which can (but do not have to) be overwritten by \code{impl} blocks.


\begin{figure}[b]
  \centering
    \begin{subfigure}[t]{.47\textwidth}
    \begin{rustcode}
      trait Iterator {
          type Item;
          fn next(&mut self)
              -> Option<Self::Item>;
      }
    \end{rustcode}
    \caption{
      The standard library's \codebox{Iterator} trait.
      The implementing type specifies what items are yielded from the iterator via the associated type.
    }
  \end{subfigure}
  \hspace{.04\textwidth}
  \begin{subfigure}[t]{.47\textwidth}
    \begin{rustcode}
      trait Float {
          const PI: Self;
          const INFINITY: Self;
          // ...
      }
    \end{rustcode}
    \caption{
      A trait that could be written to abstract over \codebox{f32} and \codebox{f64}.
      Each implementing type needs to provide special values of itself via the associated constants.
    }
  \end{subfigure}
  \caption{
    Examples for associated types and constants.
  }
  \label{fig:associated-type-const}
\end{figure}



Traits are used by many other Rust features, including operator overloading (e.\,g. the \code{PartialOrd} trait mentioned above), destructors (the \code{Drop} trait) and closures.
Particularly interesting are the \code{Send} and \code{Sync} traits which form the foundation for memory safe concurrency (i.\,e. preventing all data races).

Traits can be used in two ways: statically and dynamically dispatched.
The kind of dispatch is not specified in the trait definition, but in how the trait is used.
This means that a single trait can be used with dynamic dispatch in one situation and with static dispatch in another.
An example of the two types of usage can be seen in figure~\ref{fig:dispatch}.

\newpage
\begin{figure}[t]
  \centering
    \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
      fn print_area<S: Shape>(shape: &S) {
          println!("{}", shape.area());
      }
    \end{rustcode}
  \end{minipage}
  \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
      fn print_area(shape: &dyn Shape) {
          println!("{}", shape.area());
      }
    \end{rustcode}
  \end{minipage}
  \caption{
    The two types of dispatch.
    On the left, static dispatch is used (via a type parameter with trait bound).
    On the right, dynamic dispatch is used (via a trait object).
  }
  \label{fig:dispatch}
\end{figure}

With static dispatch, a new copy of the generic item is made for each way it is instantiated.
Calling the statically dispatched version of \code{print_area} twice, once with a \code{Circle} and once with a \code{Square}, is equivalent to having defined \code{print_area} twice (once for \code{Circle} and once for \code{Square}).
This process is called \emph{monomorphization} and is also used when instantiating \cpp templates.
Dynamic dispatch, on the other hand, uses \emph{vtables} and dynamic/virtual calls.
\cpp's virtual methods and most object-oriented languages use dynamic dispatch.

The main advantage of monomorphization over dynamic dispatch is execution speed.
With static dispatch, the compiler has full knowledge about the type and method body and is thus able to optimize the generated code very well.
With \emph{inlining}, the optimizer is often able to completely remove the call to the trait method, making the usage of traits completely zero-overhead.
This is the main way by which Rust is able to achieve \emph{zero cost abstractions}.

An extreme case of good optimization due to static dispatch is the \code{Iterator} trait.
An iterator is simply a sequence of items of a specific type.
The trait features a variety of different helper methods -- called \emph{iterator adaptors} -- which can be used to create a new iterator from an existing one.
For example, \code{1..8} is the Rust syntax for a range and represents an iterator over integers: 1, 2, 3, 4, 5, 6, 7 (the upper limit is excluded).
A new iterator can be created by filtering the existing one to remove some elements: \code{(1..8).filter(|&x| x % 2 == 0)}.
This expression is an iterator over the items 2, 4, 6.
Taking this further, with \code{map}, each item can be changed to something else.
\code{(1..8).filter(|&x| x % 2 == 0).map(|x| x * x)} is an iterator over the items 4, 16, 36.

While programming at this high a level looks like it involves many method calls and significant runtime overhead, these iterator chains are compiled down to almost optimal machine code most of the time.

\vspace{8mm}
\section{Ownership and Borrowing}

In order to guarantee memory safety and robustness, Rust uses a few concepts not found in most other languages.
One such concept is \emph{ownership}.

Different languages have different \emph{default assignment semantics}, in other words: they differ in what happens when assigning one value to another.
In Java and many other garbage-collected languages, \emph{share semantics} are used by default.
That means that, if there is a collection \code{a} and the line \code{Collection b = a;} is executed, \code{b} is now a reference to the original collection (i.\,e. \code{a} and \code{b} reference the same collection).
\cpp on the other hand, defaults to \emph{copy semantics}.
In \cpp, \code{b} would be an exact (usually deep) copy of \code{a}; changing \code{b} would not influence \code{a}.

Rust uses neither of those solutions: referencing a value requires taking a reference to it explicitly; cloning a value also requires an explicit call to \code{clone()}.
Instead, Rust uses \emph{move semantics}.
In Rust, after the assignment, the original collection can be accessed through the variable \code{b}, while the variable \code{a} is not usable anymore.
The latter is checked by the compiler and compilation will fail with an error when a variable that has been moved from is accessed (see figure~\ref{fig:string-move}).


\begin{figure}[t]
  \centering
  \begin{minipage}[t]{.5\textwidth}
    \begin{rustcode}
      @\playground{?version=stable&mode=debug&edition=2018&gist=e367f6069e48d4c2a7306479217af34c}@
      fn main() {
          let a = String::from("hello");
          let b = a;
          println!("{}", b);
          println!("{}", a);
      }
    \end{rustcode}
  \end{minipage}
  \hspace{2mm}
  \begin{minipage}[t]{.47\textwidth}
    \footnotesize
    \vspace{1mm}
    \begin{verbatim}
error[E0382]: borrow of moved value: `a`
 --> src/main.rs:5:20
  |
2 |     let a = String::from("hello");
3 |     let b = a;
  |             - value moved here
4 |     println!("{}", b);
5 |     println!("{}", a);
  |                    ^ value borrowed here
    \end{verbatim}
  \end{minipage}
  \caption{Attempting to use a value that has been moved results in a compiler error.}
  \label{fig:string-move}
\end{figure}

Optional move semantics have been introduced in \cppeleven, but they are not as secure as in Rust.
For example, the \cpp compiler does not raise an error when the programmer accesses the variable that was moved from, although this is usually unsafe.

There is one notable exception to Rust's move semantics: types that implement the trait \code{Copy} use copy semantics.
That trait is only implemented by types that can be correctly cloned by simply copying the bits of the type (i.\,e. the bits on the stack).
For example, \code{Vec<T>} cannot implement that trait, because it consists of a pointer to data; simply copying the pointer without copying the buffer behind that pointer would mean that two instances of \code{Vec<T>} think they own a buffer, leading to a double free when the destructor of the two instances is called.
All primitive types implement \code{Copy}, but user-defined types can also implement it, as long as all their fields implement the trait, too.

\vspace{8mm}

The concept of \emph{borrowing} is related to references:
in Rust, taking a reference to a value is also called \enquote{borrowing that value} and during the time where a reference to a value exists, that value is said to be \enquote{borrowed}.
Two different kinds of borrows, immutable (\code{&T}) and mutable ones (\code{&mut T}), are distinguished.

There is a central rule regarding the use of references: \textbf{at any point in time, each value can \emph{either} be referenced by any number of immutable references \emph{or} by exactly one mutable reference}.
This is also called \emph{Aliasing xor Mutability} (although \emph{nand} would technically be more correct).
This means that there cannot exist a mutable and an immutable reference to the same value at the same time.
Like the ownership analysis mentioned above, this rule is also entirely enforced at compile time.
Rust references compile down to simple pointers.

This restriction might initially sound too strict, but there are many reasons why it is a good idea.
Figure~\ref{fig:vector-bad} illustrates one of those reasons.
In practice, this rule is not as problematic as one might assume.
Only in very few situations is it necessary to work around this problem, which can be done in a variety of ways.
One notable \enquote{escape hatch} is called \emph{interior mutability}, which describes the ability to mutate some data through a \code{&T} reference.
This is only possible via carefully designed interfaces, like the type \code{Mutex} from the standard library.

\begin{figure}[t]
  \centering
    \begin{minipage}[t]{.49\textwidth}
    \begin{rustcode}
      let mut v = vec![5, 6];
      let a = &v[0];
      v.push(7);
      println!("{}", a);
    \end{rustcode}
  \end{minipage}
  \begin{minipage}[t]{.49\textwidth}
    \begin{cppcode}
      auto v = vector<int>{5, 6};
      const auto& a = v[0];
      v.push_back(7);
      cout << a << endl;
    \end{cppcode}
  \end{minipage}
  \caption{
    A classical example of why mutability with aliasing can easily lead to memory unsafety.
    The \codebox{push}/\codebox{push\_back} might trigger an internal reallocation which would invalidate the reference \codebox{a}.
    The Rust version does not compile due to the \emph{aliasing xor mutability} rule, while the \cpp version compiles fine but exhibits \emph{undefined behavior} due to memory unsafety when executing.
  }
  \label{fig:vector-bad}
\end{figure}

Finally, due to compile-time lifetime-tracking, the compiler can make sure that references never outlive the value they are referencing.
Thus, references always point to valid objects.
It is possible, and sometimes necessary, for the programmer to explicitly annotate lifetimes on function signatures, but as this is not important to understanding this thesis, it will not be explained here.

While Rust can almost always prove the memory-safety of a program, in some rare cases, it is necessary to write code outside of the compiler's protection.
For that reason, Rust offers \code{unsafe} blocks.
Within such a block, the programmer can work with raw pointers and do a few other things that are not allowed outside of an \code{unsafe} block.
But again, using \code{unsafe} is not necessary in the vast majority of Rust code.
It is actually considered bad style to use \code{unsafe} code where it can be avoided.
Almost all \code{unsafe} code is hidden behind safe interfaces; so while building blocks like \code{Vec<T>} and \code{Mutex<T>} cannot be efficiently implemented without \code{unsafe} code, users can use their safe interface without needing to worry about memory safety.


\vfill

\begin{center}
\rule{.8\textwidth}{.15mm}
\end{center}

As can be seen from this chapter, Rust is a good choice for writing robust high-performance applications and libraries.
In fact, in the opinion of the author, Rust is a better choice than \cpp for almost all new projects.
The next chapter discusses how this language is used to create \code{lox}.
\vspace{1cm}

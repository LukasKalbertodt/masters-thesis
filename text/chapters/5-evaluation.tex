\chapter{Evaluation}

In order to answer the questions raised in the introduction, the library \code{lox} is evaluated in this chapter.
This is done by, for example, comparing the execution speeds of \code{lox}, OpenMesh and PMP in several different benchmarks.
Furthermore, example code written with these three libraries is compared.  TODO: write this better.

Already during development, \code{lox}'s capabilities and ease of use were constantly tested by writing example programs and other tools.
As mentioned in the previous chapter, the command line utility \code{lox-cli} is developed alongside the main library to make sure the library offers all features such an application might require from it.
Additionally, an experimental application for rendering polygon meshes to SVG\footnote{Scalable Vector Graphic} files was developed outside of the main project, also assessing \code{lox}'s capabilities.
That application is not technically part of this master's thesis, but was used to create the images of meshes in this report, meaning they are all vector instead of pixel graphics.


\section{Execution Speed}

Geometry processing often has to deal with very large meshes, making the performance of geometry processing libraries very important.
Additionally, comparing the speed of \code{lox} to existing libraries is necessary in order to determine whether the abstractions employed by \code{lox} can be used without runtime overhead.
This chapter presents and discusses a number of different benchmarks.

All benchmarks were performed on a completely idle \textsf{Thinkpad T-460p} which, as already mentioned in chapter~4, contains an \textsf{Intel i7-6700\,HQ} and runs \textsf{Ubuntu 18.04}.
Of course, the notebook was \emph{not} running on battery during the benchmarks.
Additionally, at all times during the benchmarks, plenty of free main memory was available.
Each benchmark first executes the to be measured code 20~times as a warm-up without measuring anything.
Afterwards, the code is repeated 100 times and each iteration is measured individually.
From the 100 measured durations, the mean and standard deviation are calculated.

As already mentioned, the code, test meshes and raw results of all benchmarks can be found here: \url{https://github.com/LukasKalbertodt/masters-thesis}.

%TODO: Mention that DEM is not yet as optimized as it can be


\newpage
\subsection{Input/Output}

Some kind of IO can be found in most applications dealing with meshes, usually as the first and last step of said program.
While it is certainly not a particularly interesting processing step, its performance still is important to consider.
Different IO benchmarks were executed, covering this parameter space:

\begin{itemize}
  \item \textbf{Library/mesh implementation}: PMP, OpenMesh, \code{lox}'s half edge mesh (HEM), \code{lox}'s directed edge mesh (DEM) and \code{lox}'s shared vertex mesh (SVM) were tested.
  OpenMesh's and \code{lox}'s HEM were both configured for pure triangle meshes.
  \item \textbf{File format}: \textsc{Stl} and \textsc{Ply}.
  All benchmarks use little endian binary encoding.
  ASCII encoding only makes sense for tiny meshes in situations where it is necessary to manually inspect mesh data.
  Binary encoding is far more memory efficient and faster to read and write (independent of library).
  \item \textbf{Read or Write}
  \item \textbf{Mesh size}: the triangle meshes \enquote{cat} (59,292 faces) and \enquote{tiger} (232,956 faces) were tested.
  See \code{benchmarks/data/README.md} in the thesis' repository for more details.
\end{itemize}

Performing IO benchmarks comes with a few additional challenges.
Most importantly, it does not make sense to test the speed of the actual hardware disk as this is has little to do with the code performance.
To avoid this problem, a RAM disk\footnote{An allocated part of the main memory which is mounted into the file system.} can be used to store the input mesh files and as a target for all write operations.
However, this is not optimal as IO operations still have to communicate with the operating system, adding some overhead.

A better solution is to have an in-memory writer and reader in the benchmarking code to avoid interactions with the file system alltogether.
Benchmarks with both strategies were implemented for OpenMesh and \code{lox}, revealing that the RAM disk is roughly 1\% -- 6\% slower for read benchmarks and approximately 20\% -- 70\% slower for write benchmarks.
Unfortunately, PMP does not support reading from and writing to non-file streams.
To obtain a fair comparison between all three libraries, the in-memory disk solution was used for the main benchmark.

The results of the benchmark -- shown in figure~\ref{fig:io-benchmark} -- indicate a few different things:

\begin{itemize}
  \item \code{lox} outperforms the other libraries in all IO tasks, often significantly.
  \item In the \emph{read} benchmarks, \code{lox}'s HEM and DEM perform approximately equally well, with the SVM being notably faster.
  In the \emph{write} benchmarks however, the DEM performs as well as the SVM with the HEM being notably slower.
  This suggest that the DEM has the same speed as the HEM for mutating operations like \code{add_face}, but is faster for non-mutating operations.
  \item For IO operations, the choice of data structure has a notable effect on performance.
\end{itemize}

\begin{figure}[p]
  \centering
  \centerline{
    \includegraphics[width=1.1\textwidth]{svg2pdf/io-bench}
  }
  \vspace{1cm}
  \caption{
    Results of the IO benchmarks.
    The height of the bars is the mean of all measurements, the error bar displays the standard deviation.
    Values for \enquote{Write STL} benchmarks are missing for PMP, because the library only supports ASCII STL which is a lot slower than binary STL (those benchmarks took 500\,ms for \emph{cat} and 2000\,ms for \emph{tiger}).
  }
  \label{fig:io-benchmark}
\end{figure}

\newpage

\subsection{Algorithms}

\lipsum[1]


\newpage
\section{Example Code}

\begin{figure}[p]
  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{lox}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      use lox::{
          ds::SharedVertexMesh,
          fat::MiniMesh,
          io,
      };

      fn main() -> Result<(), io::Error> {
          type MyMesh = MiniMesh<SharedVertexMesh>;

          let mesh: MyMesh = io::read_file("input.stl")?;
          io::write_file(&mesh, "output.ply")?;

          Ok(())
      }
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{OpenMesh}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      #include <iostream>
      #include <OpenMesh/Core/IO/MeshIO.hh>
      #include <OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh>

      typedef OpenMesh::TriMesh_ArrayKernelT<> MyMesh;

      int main() {
          MyMesh mesh;
          if (!OpenMesh::IO::read_mesh(mesh, "input.stl")) {
              std::cerr << "Error reading file" << std::endl;
              return 1;
          }

          if (!OpenMesh::IO::write_mesh(mesh, "output.ply")) {
              std::cerr << "Error writing file" << std::endl;
              return 1;
          }
      }
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{PMP}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      #include <pmp/SurfaceMesh.h>

      using pmp::SurfaceMesh;

      int main() {
          SurfaceMesh mesh;
          if (!mesh.read("input.stl")) {
              std::cerr << "Error reading file" << std::endl;
              return 1;
          }

          if (!mesh.write("output.ply")) {
              std::cerr << "Error writing file" << std::endl;
              return 1;
          }
      }
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code loading one mesh file and writing the same mesh into another file.
    OpenMesh and PMP default to ASCII encoding when writing files, \codebox{lox} uses binary encoding by default.
  }
\end{figure}

\begin{figure}[p]
  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{lox}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      let (mesh, vertex_positions) = mesh! {
          type: SharedVertexMesh,
          vertices: [
              v0: Point3::new(0.0, 0.0, 0.0),
              v1: Point3::new(0.0, 1.0, 0.0),
              v2: Point3::new(1.0, 0.0, 0.0),
              v3: Point3::new(1.0, 1.0, 0.0),
          ],
          faces: [
              [v0, v2, v1],
              [v2, v3, v1],
          ]
      };
      let mesh = MiniMesh { mesh, vertex_positions };
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{OpenMesh}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      MyMesh mesh;

      const auto v0 = mesh.add_vertex(MyMesh::Point(0.0, 0.0, 0.0));
      const auto v1 = mesh.add_vertex(MyMesh::Point(0.0, 1.0, 0.0));
      const auto v2 = mesh.add_vertex(MyMesh::Point(1.0, 0.0, 0.0));
      const auto v3 = mesh.add_vertex(MyMesh::Point(1.0, 1.0, 0.0));

      mesh.add_face(v0, v2, v1);
      mesh.add_face(v2, v3, v1);
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{PMP}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      SurfaceMesh mesh;

      const auto v0 = mesh.add_vertex(Point(0.0, 0.0, 0.0));
      const auto v1 = mesh.add_vertex(Point(0.0, 1.0, 0.0));
      const auto v2 = mesh.add_vertex(Point(1.0, 0.0, 0.0));
      const auto v3 = mesh.add_vertex(Point(1.0, 1.0, 0.0));

      mesh.add_triangle(v0, v2, v1);
      mesh.add_triangle(v2, v3, v1);
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code manually creating a mesh with two triangles.
  }
\end{figure}

\begin{figure}[p]
\vspace{2mm}
  \rotatebox{0}{\textsf{\Large \textbf{lox}}}\\[-3mm]

  \hspace{.04\textwidth}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      algo::subdivision::sqrt3(&mut mesh.mesh, &mut mesh.vertex_positions, 1);
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \vspace{2mm}
  \rotatebox{0}{\textsf{\Large \textbf{OpenMesh}}}\\[-3mm]

  \hspace{.04\textwidth}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      OpenMesh::Subdivider::Uniform::Sqrt3T<MyMesh, float>()(mesh, 1);
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \vspace{2mm}
  \rotatebox{0}{\textsf{\Large \textbf{PMP}}}\\[-3mm]

  \hspace{.04\textwidth}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      auto sub = SurfaceSubdivision(mesh);
      sub.sqrt3();
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code executing the \enquote{sqrt3} algorithm offered by the libraries.
  }
\end{figure}

\begin{figure}[p]
  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{lox}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      mesh.vertex_positions = mesh.mesh.vertices().map(|v| {
          let old_pos = mesh.vertex_positions[v.handle()];
          let new_pos = if v.is_boundary() {
              old_pos
          } else {
              v.adjacent_vertices()
                  .map(|n| mesh.vertex_positions[n.handle()])
                  .centroid()
                  .unwrap()
          };
          (v.handle(), new_pos)
      }).collect();
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{OpenMesh}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      auto cogs = OpenMesh::makeTemporaryProperty<VertexHandle, MyMesh::Point>(mesh);
      for (const auto& vh : mesh.vertices()) {
          if (mesh.is_boundary(vh)) {
              cogs[vh] = mesh.point(vh);
          } else {
              cogs[vh] = {0, 0, 0};
              int valence = 0;
              for (const auto& vvh : mesh.vv_range(vh)) {
                  cogs[vh] += mesh.point(vvh);
                  valence += 1;
              }
              cogs[vh] /= valence;
          }
      }

      for (const auto& vh : mesh.vertices()) {
          mesh.point(vh) = cogs[vh];
      }
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{PMP}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      auto new_pos = mesh.add_vertex_property<Point>("v:new_pos");
      auto points = mesh.get_vertex_property<Point>("v:point");

      for (const auto v: mesh.vertices()) {
          if (mesh.is_boundary(v)) {
              new_pos[v] = points[v];
          } else {
              auto total_displacement = vec3(0, 0, 0);
              size_t valence = 0;
              for (const auto neighbor: mesh.vertices(v)) {
                  total_displacement += points[neighbor];
                  valence += 1;
              }
              new_pos[v] = total_displacement / valence;
          }
      }

      for (const auto v: mesh.vertices()) {
          points[v] = new_pos[v];
      }
      mesh.remove_vertex_property(new_pos);
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code performing a simple mesh smoothing.
  }
\end{figure}


\newpage
\section{Summary}

\lipsum[1]

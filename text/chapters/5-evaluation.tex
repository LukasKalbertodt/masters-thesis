\chapter{Evaluation}

In order to answer the questions raised in the introduction, the library \code{lox} is evaluated in this chapter.
As part of that assessment, \code{lox} is compared to the \cpp libraries OpenMesh and PMP by measuring differences in execution speed and examining some example programs written with those libraries.

Already during development, \code{lox}'s capabilities and ease of use were constantly tested by writing example programs and other tools.
As mentioned in the previous chapter, the command line utility \code{lox-cli} is developed alongside the main library to make sure the library offers all features such an application might require from it.
Additionally, an experimental application for rendering polygon meshes to SVG\footnote{Scalable Vector Graphic} files was implemented outside of the main project, also evaluating \code{lox}'s capabilities.
That application is not part of this master's thesis, but was used to create the images of meshes in this report.
As such, all of those images are pure vector graphics.


\section{Execution Speed}

Geometry processing often has to deal with very large meshes, making the performance of geometry processing libraries highly important.
Additionally, comparing the speed of \code{lox} to existing libraries is necessary in order to determine whether the abstractions employed by \code{lox} can be used without runtime overhead.
This chapter presents and discusses a number of different benchmarks.

All benchmarks were performed on a completely idle \textsf{Thinkpad T-460p} which, as already mentioned in \autoref{chap:memory-layout}, contains an \textsf{Intel i7-6700\,HQ} and runs \textsf{Ubuntu 18.04}.
Of course, the notebook was \emph{not} running on battery during the benchmarks.
Additionally, plenty of free main memory was available at all times.
The benchmarking routine first executes the code to be tested $\frac{N}{5}$~times as a warm-up without measuring any durations.
Afterwards, the code is repeated $N$ times and each iteration is measured individually.
From the $N$ measured durations, the mean and standard deviation are calculated.
The IO benchmarks use $N = 100$, the algorithm benchmarks use $N = 500$.

Some benchmarks also test the directed edge mesh implemented in \code{lox}.
It is important to note that this DEM implementation, unlike the HEM implementation, is fairly young, meaning that only very little optimization work has been put into it.
Consequently, performance of DEM operations might increase in the future.
These benchmark results are not a fair comparison between the two different data structures.

As already mentioned, the code, test meshes and raw results of all benchmarks can be found here: \url{https://github.com/LukasKalbertodt/masters-thesis}.


\newpage
\subsection{Input/Output}

Some kinds of IO operations are required in most applications dealing with meshes, usually as the first and last step of said program.
While it is certainly not a particularly interesting processing step, due to its ubiquity, its performance still is important to consider.
Different IO benchmarks were executed, covering the following parameter space:

\begin{itemize}
  \item \textbf{Library/mesh implementation}: PMP, OpenMesh, \code{lox}'s half edge mesh (HEM), \code{lox}'s directed edge mesh (DEM) and \code{lox}'s shared vertex mesh (SVM) were tested.
  OpenMesh's and \code{lox}'s HEM were both configured for pure triangle meshes.
  \item \textbf{File format}: \textsc{Stl} and \textsc{Ply}.
  All benchmarks use little endian binary encoding.
  ASCII encoding only makes sense for tiny meshes in situations where it is necessary to manually inspect mesh data.
  Binary encoding is far more memory efficient and faster to read and write (independent of library).
  \item \textbf{Read or Write}
  \item \textbf{Mesh size}: the triangle meshes \enquote{cat} (59,292 faces) and \enquote{tiger} (232,956 faces) were tested.
  See \code{benchmarks/data/README.md} in the thesis' repository for more details.
\end{itemize}

Performing IO benchmarks comes with a few additional challenges.
Most importantly, it does not make sense to test the speed of the actual hardware disk as this has little to do with the code performance.
To avoid this problem, a RAM disk\footnote{An allocated part of the main memory which is mounted into the file system.} can be used to store the input mesh files and as a target for all write operations.
However, this is not optimal as IO operations still have to communicate with the operating system, adding some overhead.

A better solution is to have an in-memory writer and reader in the benchmarking code to avoid interactions with the file system altogether.
Benchmarks with both strategies were implemented for OpenMesh and \code{lox}, revealing that the RAM disk is roughly 1\% -- 6\% slower for read benchmarks and approximately 20\% -- 70\% slower for write benchmarks.
Unfortunately, PMP does not support reading from and writing to non-file streams.
To obtain a fair comparison between all three libraries, the RAM disk solution was used for the benchmark below.

\vfill

The results of these benchmarks -- shown in figure~\ref{fig:io-benchmark} -- indicate a few different things:

\begin{itemize}
  \item \code{lox} outperforms the other libraries in all IO tasks, often significantly.
  \item In the \emph{read} benchmarks, \code{lox}'s HEM and DEM perform approximately equally well, with the SVM being notably faster.
  In the \emph{write} benchmarks however, the DEM performs as well as the SVM with the HEM being notably slower.
  This suggests that the DEM has the same speed as the HEM for mutating operations like \code{add_face}, but is faster for non-mutating operations.
  \item For IO operations, the choice of data structure has a notable effect on performance.
\end{itemize}

\begin{figure}[p]
  \centering
  \centerline{
    \includegraphics[width=1.1\textwidth]{svg2pdf/io-bench}
  }
  \vspace{1cm}
  \caption{
    Results of the IO benchmarks.
    The height of the bars is the mean of all measurements, the error bar displays the standard deviation.
    Values for \enquote{Write STL} benchmarks are missing for PMP, because the library only supports ASCII STL which is a lot slower than binary STL (those benchmarks took 500\,ms for \emph{cat} and 2000\,ms for \emph{tiger}).
  }
  \label{fig:io-benchmark}
\end{figure}

\newpage

\subsection{Algorithms}

In many geometry processing applications, algorithms operating on meshes take significantly longer to execute than IO operations, making their performance particularly relevant.
To compare the respective speeds of the libraries, many different algorithms were benchmarked.
Most of these algorithms are fairly simple and use only a few methods of the mesh, in order to draw conclusions about the speed of particular mesh operations.

Like the IO benchmarks, all algorithms were tested with the triangle meshes \enquote{cat} and \enquote{tiger}.
Loading these meshes was done up-front and is not included in the measurements.
The half edge meshes of all three libraries were tested in all benchmarks, with most benchmarks additionally testing \code{lox}'s directed edge mesh as well.
The following algorithms were used:

\begin{itemize}
  \item \textbf{\enquote{Boundary Faces}}: counts the number of boundary faces.
  \emph{Operations}: iterate over faces, face boundary check.
  \item \textbf{\enquote{Boundary Vertices}}: counts the number of boundary vertices.
  \emph{Operations}: iterate over vertices, vertex boundary check.
  \item \textbf{\enquote{Face Normals}}: calculates and externally stores the normal of each face.
  \emph{Operations}: iterate over faces, \adj{F}{V}, obtain vertex position.
  \item \textbf{\enquote{Vertex Normals}}: calculates and externally stores the normal of each vertex, which is calculated as the normalized sum of the adjacent faces' normals.
  The face normals are calculated up-front are not included in the measurement.
  \emph{Operations}: iterate over vertices, \adj{V}{F}, obtain face normal.
  \item \textbf{\enquote{Simple Smooth}}: moves each non-boundary vertex to the centroid of all neighbor vertices.
  \emph{Operations}: iterate over vertices, \adj{V}{V}, vertex boundary check, obtain vertex position.
  \item \textbf{\enquote{$\sqrt{3}$-subdivision}}: performs one iteration of said algorithm \cite{kobbelt20003}.
  This algorithm is by far the most elaborate one from this list.
  \emph{Operations} include: face split and edge flip.
\end{itemize}

\vspace{1cm}

The results of these benchmarks can be seen in figure~\ref{fig:algo-benchmark} and are discussed in the page thereafter.

\begin{figure}[p]
  \centering
  \centerline{
    \includegraphics[width=1.15\textwidth]{svg2pdf/algo-bench}
  }
  \vspace{1cm}
  \caption{
    Results of the algorithm benchmarks.
    The height of the bars is the mean of all measurements, the error bar displays the standard deviation.
  }
  \label{fig:algo-benchmark}
\end{figure}

\newpage

These benchmarking results are a lot more mixed and less clear than the ones of the IO benchmarks.
For one, no library clearly outperforms the others: each library performs worst in at least one benchmark.
Additionally, in the more simple benchmarks, the order of libraries often changes between the smaller and larger mesh.

Compared to the IO benchmarks, the average standard deviation is slightly higher, particularly for the benchmarks using the small \enquote{cat} mesh.
This is probably just a consequence of the smaller durations measured here, but it \emph{could} also be an indication for the larger influence of indeterministic caching-effects.
The fact that CPU-caches play a central role in these benchmarks can be seen in the difference between the \enquote{cat} and \enquote{tiger} meshes:
while \enquote{tiger} has roughly four times as many faces as \enquote{cat}, the benchmarks take approximately between five and ten times as long.

Only considering the half edge mesh implementations, \code{lox} is positioned mostly somewhere in between PMP and OpenMesh -- with two notable exceptions:
\code{lox} performs worse than the other libraries in the smoothing benchmark, but outperforms them in the $\sqrt{3}$-subdivision benchmark.
The reasons for these differences are not entirely clear, but profiling these benchmarks hinted at bound checks being one of the major problems for \code{lox}'s performance.
As mentioned before, bound checks have to be used when accessing arrays to guarantee memory safety.
Unfortunately, these checks are not removed by the optimizer when accessing external property maps, meaning that benchmarks performing many of these accesses (like \enquote{smoothing}) suffer from these checks.
There might be ways to omit these checks without sacrificing memory safety, but none of these has been tested in \code{lox} yet.

The performance of the directed edge mesh differs widely between benchmarks, sometimes being significantly faster than the HEMs, while being equally fast in other cases.
It can clearly outperform the HEMs in the benchmarks \enquote{boundary face} and \enquote{face normals}, which makes sense, as these algorithms heavily use the face neighborhood.
Unlike the HEM, the DEM stores the immediate face neighborhood in only one memory location, meaning that accessing it is very cache friendly.
Additionally, when counting boundary vertices, the DEM outperforms the other data structures on the large mesh.
This is probably caused by the DEM using less memory, meaning that more of the mesh fits into the CPU-caches, decreasing the number of cache-misses.



\newpage
\section{Example Code}

Speed is by far not the only factor determining the quality of a software library.
For example, if the library is hard to understand and use, the increase in development time usually outweighs the gains due to higher execution speed.
Unfortunately, it is often not possible to objectively evaluate a library's ease of use or the \enquote{readability} of its code -- particularly when comparing different languages.
However, to get a sense for the differences between \code{lox}, OpenMesh and PMP, this section shows a few example tasks realized with the different libraries.

Figure~\ref{fig:example-io} shows an example that reads the file \code{input.stl} and writes the mesh back into \code{output.ply}.
Two main differences between the \code{lox} version and the two other versions can be observed.
Firstly, with \code{lox}, the mesh is returned by the \code{read_file} function, while OpenMesh and PMP already require an instance of a mesh to read into, i.\,e., a variable has to created before reading.
Secondly, \code{lox}'s IO functions report errors via \code{io::Error} which includes information about the underlying cause, whereas OpenMesh's and PMP's functions signal success or failure via a single \code{bool} which does not carry any additional information.

In figure~\ref{fig:example-build}, code manually building a simple mesh is shown.
While most of the time meshes are loaded from files, creating small meshes by hand is useful for examples and unit tests.
While the two snippets using OpenMesh and PMP are very similar, the code using \code{lox} differs substantially.
That is because with \code{lox}, mesh properties -- including vertex positions -- have to be stored in external property maps.
The \code{mesh!} macro is offered to make creating meshes more convenient by allowing the user to specify mesh connectivity and properties with a custom syntax.
However, it is possible that more methods are added to \enquote{fat meshes} in the future, which would allow them to be used just like the mesh types in OpenMesh and PMP.

The small code snippets in figure~\ref{fig:example-sqrt3} show how to run the $\sqrt{3}$-subdivision algorithm \cite{kobbelt20003} on a mesh.
In \code{lox}, the algorithm is a simple function, while the other libraries require the instantiation of a class, a method of which performs the actual algorithm.

Lastly, figure~\ref{fig:example-smooth} shows a simple smoothing algorithm that moves each vertex to the centroid of all neighbor vertices (used for the \enquote{smooth} benchmarks).
This shows a number of differences between the libraries.
For one, \code{lox}'s vertex iterator iterates over \code{VertexRef}s, allowing features like \code{v.adjacent_vertices()} and \code{v.is_boundary()}, while the other two libraries iterate over vertex handles.
In OpenMesh and PMP, the property map for the new positions is created from the mesh and filled afterwards; in \code{lox} it is created by collecting an iterator over \code{(VertexHandle, Point3)} pairs.
An iterator method \code{centroid} is offered by \code{lox}, while the two \cpp versions implement that logic themselves.

In general, in situations where \code{lox} code is more concise than equivalent code for the two other libraries, this advantage is mostly due to Rust's powerful iterator system.
For one, it allows defining new methods like \code{centroid}.
But even the built-in iterator methods can make some code notably shorter.
For example, this code counts the number of boundary faces: \code{mesh.faces().filter(|f| f.is_boundary()).count()}.


\begin{figure}[p]
  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{lox}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      use lox::{
          ds::SharedVertexMesh,
          fat::MiniMesh,
          io,
      };

      fn main() -> Result<(), io::Error> {
          type MyMesh = MiniMesh<SharedVertexMesh>;

          let mesh: MyMesh = io::read_file("input.stl")?;
          io::write_file(&mesh, "output.ply")?;

          Ok(())
      }
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{OpenMesh}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      #include <iostream>
      #include <OpenMesh/Core/IO/MeshIO.hh>
      #include <OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh>

      typedef OpenMesh::TriMesh_ArrayKernelT<> MyMesh;

      int main() {
          MyMesh mesh;
          if (!OpenMesh::IO::read_mesh(mesh, "input.stl")) {
              std::cerr << "Error reading file" << std::endl;
              return 1;
          }

          if (!OpenMesh::IO::write_mesh(mesh, "output.ply")) {
              std::cerr << "Error writing file" << std::endl;
              return 1;
          }
      }
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{PMP}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      #include <iostream>
      #include <pmp/SurfaceMesh.h>

      using pmp::SurfaceMesh;

      int main() {
          SurfaceMesh mesh;
          if (!mesh.read("input.stl")) {
              std::cerr << "Error reading file" << std::endl;
              return 1;
          }

          if (!mesh.write("output.ply")) {
              std::cerr << "Error writing file" << std::endl;
              return 1;
          }
      }
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code loading one mesh file and writing the same mesh into another file.
    OpenMesh and PMP default to ASCII encoding when writing files, \codebox{lox} uses binary encoding by default.
    This is the only example that includes imports and function declarations.
  }
  \label{fig:example-io}
\end{figure}

\begin{figure}[p]
  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{lox}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      let (mesh, vertex_positions) = mesh! {
          type: SharedVertexMesh,
          vertices: [
              v0: Point3::new(0.0, 0.0, 0.0),
              v1: Point3::new(0.0, 1.0, 0.0),
              v2: Point3::new(1.0, 0.0, 0.0),
              v3: Point3::new(1.0, 1.0, 0.0),
          ],
          faces: [
              [v0, v2, v1],
              [v2, v3, v1],
          ]
      };
      let mesh = MiniMesh { mesh, vertex_positions };
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{OpenMesh}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      MyMesh mesh;

      const auto v0 = mesh.add_vertex(MyMesh::Point(0.0, 0.0, 0.0));
      const auto v1 = mesh.add_vertex(MyMesh::Point(0.0, 1.0, 0.0));
      const auto v2 = mesh.add_vertex(MyMesh::Point(1.0, 0.0, 0.0));
      const auto v3 = mesh.add_vertex(MyMesh::Point(1.0, 1.0, 0.0));

      mesh.add_face(v0, v2, v1);
      mesh.add_face(v2, v3, v1);
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{PMP}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      SurfaceMesh mesh;

      const auto v0 = mesh.add_vertex(Point(0.0, 0.0, 0.0));
      const auto v1 = mesh.add_vertex(Point(0.0, 1.0, 0.0));
      const auto v2 = mesh.add_vertex(Point(1.0, 0.0, 0.0));
      const auto v3 = mesh.add_vertex(Point(1.0, 1.0, 0.0));

      mesh.add_triangle(v0, v2, v1);
      mesh.add_triangle(v2, v3, v1);
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code manually creating a mesh with two triangles.
  }
  \label{fig:example-build}
\end{figure}

\begin{figure}[p]
  \vspace{2mm}
  \rotatebox{0}{\textsf{\Large \textbf{lox}}}\\[-3mm]

  \hspace{.04\textwidth}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      algo::subdivision::sqrt3(&mut mesh.mesh, &mut mesh.vertex_positions, 1);
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \vspace{2mm}
  \rotatebox{0}{\textsf{\Large \textbf{OpenMesh}}}\\[-3mm]

  \hspace{.04\textwidth}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      OpenMesh::Subdivider::Uniform::Sqrt3T<MyMesh, float>()(mesh, 1);
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \vspace{2mm}
  \rotatebox{0}{\textsf{\Large \textbf{PMP}}}\\[-3mm]

  \hspace{.04\textwidth}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      auto sub = SurfaceSubdivision(mesh);
      sub.sqrt3();
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code executing the $\sqrt{3}$-subdivision algorithm offered by the libraries.
  }
  \label{fig:example-sqrt3}
\end{figure}

\begin{figure}[p]
  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{lox}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{rustcode*}{fontsize=\footnotesize}
      mesh.vertex_positions = mesh.mesh.vertices().map(|v| {
          let old_pos = mesh.vertex_positions[v.handle()];
          let new_pos = if v.is_boundary() {
              old_pos
          } else {
              v.adjacent_vertices()
                  .map(|n| mesh.vertex_positions[n.handle()])
                  .centroid()
                  .unwrap()
          };
          (v.handle(), new_pos)
      }).collect();
    \end{rustcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{OpenMesh}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      auto cogs = OpenMesh::makeTemporaryProperty<VertexHandle, MyMesh::Point>(mesh);
      for (const auto& vh : mesh.vertices()) {
          if (mesh.is_boundary(vh)) {
              cogs[vh] = mesh.point(vh);
          } else {
              cogs[vh] = {0, 0, 0};
              int valence = 0;
              for (const auto& vvh : mesh.vv_range(vh)) {
                  cogs[vh] += mesh.point(vvh);
                  valence += 1;
              }
              cogs[vh] /= valence;
          }
      }

      for (const auto& vh : mesh.vertices()) {
          mesh.point(vh) = cogs[vh];
      }
    \end{cppcode*}
  \end{minipage}\vspace{2mm}

  \begin{minipage}{.04\textwidth}
    \rotatebox{90}{\textsf{\Large \textbf{PMP}}}
  \end{minipage}
  \begin{minipage}{.9\textwidth}
    \begin{cppcode*}{fontsize=\footnotesize}
      auto new_pos = mesh.add_vertex_property<Point>("v:new_pos");
      auto points = mesh.get_vertex_property<Point>("v:point");

      for (const auto v: mesh.vertices()) {
          if (mesh.is_boundary(v)) {
              new_pos[v] = points[v];
          } else {
              auto total_displacement = vec3(0, 0, 0);
              size_t valence = 0;
              for (const auto neighbor: mesh.vertices(v)) {
                  total_displacement += points[neighbor];
                  valence += 1;
              }
              new_pos[v] = total_displacement / valence;
          }
      }

      for (const auto v: mesh.vertices()) {
          points[v] = new_pos[v];
      }
      mesh.remove_vertex_property(new_pos);
    \end{cppcode*}
  \end{minipage}

  \caption{
    Example code performing a simple mesh smoothing.
  }
  \label{fig:example-smooth}
\end{figure}


\newpage
\section{Summary}

As can be seen from the previous chapters, \code{lox} is a viable mesh processing library which offers the basic features expected from such a package.
It allows implementing sophisticated mesh algorithms (like $\sqrt{3}$-subdivision) and it has been successfully used to create two useful applications: \code{lox-cli} and an SVG renderer.
Compared to two existing \cpp libraries, OpenMesh and PMP, \code{lox} has advantages in some areas but disadvantages in others.
Currently, \code{lox} is not as complete as the other two libraries, particularly regarding mesh algorithms.
Naturally, the library is also not nearly as mature as OpenMesh.

The main benefit of \code{lox} comes from having achieved its central goal:
to provide an abstraction over different data structures and let the programmer decide which data structure to use in which situation.
This works well and does not incur any significant runtime overhead, as shown in the benchmarks where \code{lox} outperforms the other libraries.
And as can be seen from some benchmarks, it can be very beneficial to choose a data structure other than the HEM in some situations.
Additional advantages of \code{lox} include the superior performance of IO operations and being able to use Rust, which has several advantages over \cpp.

In some areas, \code{lox} could not improve the status-quo yet.
For example, while some operations can be expressed more concisely due to \code{lox}'s use of Rust features, some other tasks require slightly more code using \code{lox} than existing \cpp libraries.
Particularly problematic for \code{lox} is the use of indices to refer to data, because generally, each array access has to be bound checked to avoid reading uninitialized memory.
Unfortunately the optimizer is not able to remove those bound checks most of the time in the context of this library, meaning that this safety guarantee incurs notable runtime overhead.
This can be seen in some of the benchmarks.
The problem could potentially be solved by using Rust's type system to \enquote{sign} (or \enquote{brand}) valid indices at compile time, a pattern explored in \cite[Chapter~6.3]{beingessner2016you}.
This, however, was not attempted in this thesis.

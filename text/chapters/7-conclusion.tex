\chapter{Conclusion}
\label{chap:conclusion}

In this thesis, the geometry processing library \code{lox} was introduced and evaluated.
It was shown that, by using the trait system offered by the Rust programming language,  it is possible to abstract over different mesh data structures without incurring any significant runtime overhead.
Furthermore, the benchmarks and code examples from chapter~\ref{chap:evaluation} demonstrate that \code{lox} is comparable to the \cpp libraries OpenMesh and PMP in terms of execution speed and ease of use.
In some cases, it even significantly outperforms the two \cpp libraries.
However, due to its young age, \code{lox} still offers notably fewer features (elaborate mesh algorithms in particular) than the other libraries.

\vfill
\section{Challenges}

While using Rust had many advantages and made the project possible in the first place, some limitations of the language presented a number of problems, ranging from mildly inconvenient to seriously restrictive.
The lack of language features for dealing with higher-kinded types (e.\,g., GATs) posed a particularly aggravating obstacle, as it required elaborate workarounds and severely limited some parts of the library's interface.
Less serious difficulties were caused by the incomplete implementations of \emph{specialization} and \emph{const generics}.

Rust's memory safety guarantees unfortunately also resulted in some complications.
For one, the central rule \emph{aliasing nand mutability} required some tweaks to the library's API to work around this deliberate language limitation, thus making some common mesh operations less intuitive to use.
More importantly, to avoid reading uninitialized memory, bound checks are required when accessing an array.
While most bound checks are removed by the optimizer during compilation, this was not the case for the majority of situations when using \code{lox} (particularly due to external property maps), resulting in a notable runtime overhead.

Finally, designing \code{lox}'s central interfaces proved particularly challenging.
Trait systems like the one used to abstract over mesh data structures have to strike the balance between flexibility and ease of use:
using fewer traits makes for a simpler API, but might exclude some use-cases.
Further experiments, improvements and testing is certainly required to find an adequate solution.

\vspace{1cm}

\newpage
\section{Future Work}

As mentioned above, there are still many ways to improve and extend \code{lox}.
Firstly, its feature set needs to be expanded by, for example, implementing more data structures, supporting more file formats and adding more mesh algorithms.
Furthermore, its core interfaces need to be polished and some design decisions need to be reconsidered.
Lastly, after \code{lox}'s initial release shortly after handing in this thesis, user-feedback will be incorporated into the library's design.

The library could also benefit a lot from experimenting with how Rust's strong type system can improve performance or avoid certain classes of bugs.
For example, while using \emph{handles} has many advantages, it also introduces potential bugs like using a handle to an already deleted element or using the handle of one mesh with another one.
There has been some research on \enquote{type branding} in Rust that could be used to solve these problems \cite{beingessner2016you, indexing}.
The same approach could potentially help to reduce the number of bound checks in certain situations.

After various mesh data structures are implemented and sufficiently optimized, it would be possible to compare their respective speeds by benchmarking their performances in a large number of different benchmarks.
This would allow for creating extensive guidelines on when to best use which data structure.
